<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analysis - Session <%= sessionId %></title>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      line-height: 1.5;
    }
    .container {
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Focus indicators */
    button:focus-visible, a:focus-visible {
      outline: 2px solid #58a6ff;
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.2);
    }

    /* Header */
    .header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      display: flex;
      align-items: center;
      gap: 16px;
      position: sticky;
      top: 0;
      background: #0d1117;
      z-index: 10;
    }
    .nav-btn {
      padding: 6px 12px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      text-decoration: none;
      font-size: 14px;
      transition: all 0.2s;
    }
    .nav-btn:hover {
      background: #30363d;
      border-color: #58a6ff;
    }
    h1 {
      color: #58a6ff;
      font-size: 20px;
      flex: 1;
    }

    /* Summary cards */
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
      margin: 20px auto;
      max-width: 1200px;
    }
    .summary-card {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 8px;
      padding: 16px;
    }
    .summary-card-label {
      font-size: 12px;
      color: #7d8590;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .summary-card-value {
      font-size: 24px;
      font-weight: 600;
      color: #e6edf3;
    }
    .summary-card-sub {
      font-size: 12px;
      color: #7d8590;
      margin-top: 2px;
    }

    /* Section */
    .section {
      margin: 24px 0;
    }
    .section-title {
      font-size: 16px;
      font-weight: 600;
      color: #e6edf3;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #30363d;
    }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 16px;
      border-bottom: 1px solid #30363d;
      padding-bottom: 0;
    }
    .tab {
      padding: 8px 16px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      color: #7d8590;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }
    .tab:hover {
      color: #c9d1d9;
    }
    .tab.active {
      color: #58a6ff;
      border-bottom-color: #58a6ff;
    }

    /* Table */
    .data-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .data-table th {
      text-align: left;
      padding: 8px 12px;
      background: #161b22;
      color: #7d8590;
      font-weight: 600;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      border-bottom: 1px solid #30363d;
      position: sticky;
      top: 57px;
      z-index: 5;
    }
    .data-table td {
      padding: 6px 12px;
      border-bottom: 1px solid #21262d;
      vertical-align: top;
    }
    .data-table tr:hover td {
      background: rgba(110, 118, 129, 0.05);
    }
    .data-table .mono {
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
    }
    .data-table .message-cell {
      max-width: 400px;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      line-height: 1.4;
      word-break: break-word;
    }
    .data-table .sortable {
      cursor: pointer;
      user-select: none;
    }
    .data-table .sortable:hover {
      color: #58a6ff;
    }
    
    /* Grouped turns table */
    .group-header-row {
      background: rgba(110, 118, 129, 0.08);
    }
    .group-header-row:hover td {
      background: rgba(110, 118, 129, 0.12) !important;
    }
    .group-header-cell {
      padding: 10px 12px !important;
      border-bottom: 2px solid #30363d !important;
      font-weight: 500;
    }
    .group-header-content {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .user-req-badge {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(88, 166, 255, 0.15);
      color: #58a6ff;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      flex-shrink: 0;
      margin-top: 2px;
    }
    .user-message-text {
      color: #e6edf3;
      flex: 1;
      line-height: 1.5;
      word-break: break-word;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .turn-row td {
      border-bottom: 1px solid #21262d;
    }
    .turn-row:last-of-type td {
      border-bottom: 2px solid #30363d;
    }
    .turn-cell {
      color: #8b949e;
    }
    .turn-link {
      color: #58a6ff;
      text-decoration: none;
      transition: color 0.2s;
    }
    .turn-link:hover {
      color: #79c0ff;
      text-decoration: underline;
    }
    .subagent-link {
      color: #58a6ff;
      text-decoration: none;
      transition: color 0.2s;
    }
    .subagent-link:hover {
      color: #79c0ff;
      text-decoration: underline;
    }
    
    /* Timeline column in table */
    .timeline-cell {
      padding: 6px 12px !important;
    }
    .timeline-bar-container {
      position: relative;
      width: 100%;
      height: 20px;
      background: rgba(110, 118, 129, 0.05);
      border-radius: 3px;
    }
    .timeline-bar {
      position: absolute;
      height: 100%;
      background: rgba(35, 134, 54, 0.7);
      border-radius: 3px;
      min-width: 2px;
      transition: background 0.2s;
    }
    .timeline-bar:hover {
      background: rgba(35, 134, 54, 0.9);
    }

    /* Duration bar */
    .duration-bar-container {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .duration-bar {
      height: 6px;
      border-radius: 3px;
      background: #1f6feb;
      min-width: 2px;
      transition: width 0.3s;
    }
    .duration-bar.subagent { background: #3fb950; }
    .duration-bar.subagent-failed { background: #f85149; }
    .duration-bar.subagent-incomplete { background: #d29922; }
    .duration-bar.tool { background: #9e6a03; }
    .duration-bar.user { background: #1f6feb; }
    .duration-bar.turn { background: #238636; }
    .duration-bar.error { background: #da3633; }

    .duration-text {
      font-size: 12px;
      color: #c9d1d9;
      white-space: nowrap;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
    }

    /* Badges */
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
    }
    .badge-subagent { background: #8957e5; color: #fff; }
    .badge-tool { background: #9e6a03; color: #fff; }
    .badge-turn { background: #238636; color: #fff; }
    .badge-read { background: rgba(88, 166, 255, 0.15); color: #58a6ff; border: 1px solid rgba(88, 166, 255, 0.3); }
    .badge-write { background: rgba(63, 185, 80, 0.15); color: #3fb950; border: 1px solid rgba(63, 185, 80, 0.3); }
    .badge-edit { background: rgba(210, 153, 34, 0.15); color: #d29922; border: 1px solid rgba(210, 153, 34, 0.3); }
    .badge-create { background: rgba(63, 185, 80, 0.15); color: #3fb950; border: 1px solid rgba(63, 185, 80, 0.3); }
    .badge-bash { background: rgba(139, 148, 158, 0.15); color: #8b949e; border: 1px solid rgba(139, 148, 158, 0.3); }
    .badge-search { background: rgba(191, 57, 137, 0.15); color: #f778ba; border: 1px solid rgba(191, 57, 137, 0.3); }
    .badge-other { background: rgba(110, 118, 129, 0.15); color: #8b949e; border: 1px solid rgba(110, 118, 129, 0.3); }

    /* Timeline */
    .timeline {
      position: relative;
      padding: 0;
    }
    .timeline-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 6px 0;
      border-bottom: 1px solid #21262d;
    }
    .timeline-item:last-child {
      border-bottom: none;
    }
    .timeline-time {
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      color: #7d8590;
      min-width: 70px;
      flex-shrink: 0;
    }
    .timeline-content {
      flex: 1;
      min-width: 0;
    }
    .timeline-file {
      color: #58a6ff;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      word-break: break-all;
    }
    .timeline-detail {
      font-size: 12px;
      color: #7d8590;
      margin-top: 2px;
    }

    /* Gantt-like chart for subagents */
    .gantt-container {
      overflow-x: auto;
      padding-bottom: 8px;
    }
    .gantt-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 6px 0;
      border-bottom: 1px solid #21262d;
    }
    .gantt-row:last-child {
      border-bottom: none;
    }
    .gantt-label {
      min-width: 200px;
      max-width: 200px;
      font-size: 13px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .gantt-bar-area {
      flex: 1;
      min-width: 300px;
      height: 24px;
      position: relative;
      background: rgba(110, 118, 129, 0.05);
      border-radius: 4px;
    }
    .gantt-bar {
      position: absolute;
      height: 100%;
      border-radius: 4px;
      min-width: 3px;
      display: flex;
      align-items: center;
      padding: 0 6px;
      font-size: 11px;
      font-weight: 500;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
    }
    .gantt-bar.subagent { background: rgba(63, 185, 80, 0.8); }
    .gantt-bar.subagent-failed { background: rgba(248, 81, 73, 0.8); }
    .gantt-bar.subagent-incomplete { background: rgba(210, 153, 34, 0.8); }
    .gantt-bar.turn { background: rgba(35, 134, 54, 0.8); }
    .gantt-bar.tool { background: rgba(158, 106, 3, 0.6); }
    .gantt-bar.agent-op {
      background: rgba(139, 148, 158, 0.3);
      border: 1px dashed rgba(139, 148, 158, 0.5);
    }

    /* Event markers on gantt bars */
    .gantt-bar { overflow: visible; }
    .event-marker {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      cursor: pointer;
      transition: transform 0.15s;
    }
    .event-marker:hover {
      transform: translate(-50%, -50%) scale(1.8);
      z-index: 10;
    }
    .event-marker--circle {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }
    .event-marker--diamond {
      width: 6px;
      height: 6px;
      transform: translate(-50%, -50%) rotate(45deg);
    }
    .event-marker:hover .event-marker--diamond-inner {
      transform: scale(1.8);
    }
    .event-marker--square {
      width: 5px;
      height: 5px;
      border-radius: 1px;
    }
    .event-marker--triangle {
      width: 0;
      height: 0;
      border-left: 4px solid transparent;
      border-right: 4px solid transparent;
      border-bottom: 7px solid currentColor;
    }
    .event-marker--cluster {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      font-weight: 700;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.3);
    }

    /* Event marker tooltip */
    .event-marker-tooltip {
      display: none;
      position: absolute;
      bottom: calc(100% + 6px);
      left: 50%;
      transform: translateX(-50%);
      background: #1c2128;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 11px;
      color: #c9d1d9;
      white-space: nowrap;
      z-index: 100;
      pointer-events: none;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .event-marker:hover .event-marker-tooltip {
      display: block;
    }

    /* Gantt label for agent-op */
    .gantt-label.agent-op {
      color: #7d8590;
      font-style: italic;
    }
    .gantt-label.agent-op .agent-op-icon {
      color: #8b949e;
      margin-right: 4px;
    }
    .gantt-label.agent-op .agent-op-summary {
      font-size: 11px;
      color: #6e7681;
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Event legend */
    .event-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 10px 14px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      margin-bottom: 12px;
    }
    .event-legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 11px;
      color: #8b949e;
    }
    .event-legend-swatch {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    .legend-toggle-btn {
      background: none;
      border: 1px solid #30363d;
      color: #8b949e;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 8px;
      transition: all 0.2s;
    }
    .legend-toggle-btn:hover {
      border-color: #58a6ff;
      color: #58a6ff;
    }

    .gantt-time-axis {
      display: flex;
      justify-content: space-between;
      margin-left: 212px;
      padding: 4px 0;
      font-size: 11px;
      color: #7d8590;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      border-top: 1px solid #30363d;
    }

    /* Unified timeline: indented child rows */
    .gantt-row.indented .gantt-label {
      padding-left: 20px;
    }

    /* Unified timeline: user-req row */
    .gantt-bar.user-req {
      background: rgba(88, 166, 255, 0.35);
      border: 1px solid rgba(88, 166, 255, 0.6);
    }
    .gantt-label.user-req {
      font-weight: 600;
      color: #e6edf3;
    }
    .gantt-label.user-req .user-req-badge {
      margin-right: 6px;
    }
    .gantt-label.user-req .user-req-msg {
      font-weight: 400;
      font-size: 11px;
      color: #8b949e;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Unified timeline: tool-summary row */
    .gantt-bar.tool-summary {
      background: rgba(158, 106, 3, 0.6);
    }
    .gantt-label.tool-summary {
      color: #d29922;
      font-weight: 500;
    }
    .gantt-label.tool-summary .tool-cat-icon {
      margin-right: 4px;
    }
    .gantt-label.tool-summary .tool-cat-count {
      color: #7d8590;
      font-size: 11px;
      margin-left: 4px;
    }

    /* Unified timeline: divider row */
    .gantt-divider {
      border-bottom: 1px solid #30363d;
      padding: 4px 0;
      margin: 2px 0;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #7d8590;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .gantt-divider::before,
    .gantt-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #30363d;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #7d8590;
      font-size: 14px;
    }

    /* Markdown Styles */
    .section h1, .section h2, .section h3 {
      color: #c9d1d9;
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.25;
    }
    .section h1 { font-size: 2em; border-bottom: 1px solid #21262d; padding-bottom: 8px; }
    .section h2 { font-size: 1.5em; border-bottom: 1px solid #21262d; padding-bottom: 8px; }
    .section h3 { font-size: 1.25em; }
    .section p { margin-bottom: 16px; }
    .section ul, .section ol { margin-bottom: 16px; padding-left: 2em; }
    .section li { margin-bottom: 8px; }
    .section code {
      background: #161b22;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: ui-monospace, 'Cascadia Code', monospace;
      font-size: 85%;
    }
    .section pre {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 16px;
      overflow-x: auto;
      margin-bottom: 16px;
    }
    .section pre code {
      background: transparent;
      padding: 0;
    }
    .section blockquote {
      border-left: 4px solid #30363d;
      padding-left: 16px;
      color: #7d8590;
      margin-bottom: 16px;
    }
    .section hr {
      border: none;
      border-top: 1px solid #21262d;
      margin: 24px 0;
    }
    .section table {
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 16px;
    }
    .section table th,
    .section table td {
      border: 1px solid #30363d;
      padding: 8px 13px;
      text-align: left;
    }
    .section table th {
      background: #161b22;
      font-weight: 600;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .summary-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      .gantt-label {
        min-width: 120px;
        max-width: 120px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <a href="/session/<%= sessionId %>" class="nav-btn">‚Üê Back to Session</a>
    <h1>‚è± Analysis: <%= sessionId %>
      <% if (metadata.sessionStatus === 'wip') { %>
        <span style="font-size: 12px; padding: 2px 8px; border-radius: 3px; background: rgba(210, 153, 34, 0.2); color: #d29922; border: 1px solid rgba(210, 153, 34, 0.4); vertical-align: middle; margin-left: 8px;">üîÑ WIP</span>
      <% } %>
    </h1>
  </div>

  <div class="container" id="app"></div>

  <!-- Vue 3 -->
  <script src="https://cdn.jsdelivr.net/npm/vue@3.5.28/dist/vue.global.prod.js" integrity="sha384-EyKhbIJoP1t1fKIFRNEfYKy4uy8qxs7UNS4Cab53xyXqCTUB1PCoxeFsD0G/NX9W" crossorigin="anonymous"></script>

  <script>
    window.sessionData = {
      sessionId: '<%= sessionId %>',
      metadata: <%- JSON.stringify(metadata).replace(/</g, '\\u003c').replace(/>/g, '\\u003e').replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029') %>
    };
  </script>

  <script>
    const { createApp, ref, computed, onMounted, onUnmounted, reactive } = Vue;

    const app = createApp({
      setup() {
        const sessionId = ref(window.sessionData.sessionId);
        const metadata = ref(window.sessionData.metadata);
        const events = ref([]);
        const loading = ref(true);
        const error = ref(null);
        const activeTab = ref('timeline');
        const sortField = ref('timestamp');
        const sortDir = ref('asc');
        const insightReport = ref(null);
        const insightLog = ref(null);
        const insightLoading = ref(false);
        const insightError = ref(null);
        const insightGeneratedAt = ref(null);
        const showMarkerLegend = ref(false);
        const copyLabel = ref('üìä Copy as Mermaid Gantt');

        const copyTimelineMarkdown = async () => {
          const items = unifiedTimelineItems.value;
          if (!items.length) return;

          // Helper: convert timestamp to Unix epoch milliseconds
          const toEpochMs = (ts) => {
            if (!ts) return 0;
            return new Date(ts).getTime();
          };

          // Sanitize label for Mermaid: strip chars that break syntax or could escape the code block
          const sanitize = (str) => (str || '').replace(/[`\n\r]/g, '').replace(/[:;#]/g, '-').replace(/\s+/g, ' ').trim().substring(0, 100);

          // Deduplicate task IDs within the mermaid block
          const usedIds = {};
          const uniqueId = (base) => {
            const clean = base.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
            if (!usedIds[clean]) { usedIds[clean] = 1; return clean; }
            usedIds[clean]++;
            return clean + '_' + usedIds[clean];
          };

          const lines = [];
          lines.push('```mermaid');
          lines.push('gantt');
          lines.push('    title Session Timeline ‚Äì ' + sanitize(sessionId.value));
          lines.push('    dateFormat x');
          lines.push('    axisFormat %H:%M:%S');
          lines.push('');

          for (const item of items) {
            if (item.rowType === 'user-req') {
              const msg = sanitize(item.message || 'No message').substring(0, 40);
              const label = 'UserReq ' + item.userReqNumber + ' ‚Äì ' + msg + ' (' + formatDuration(item.duration) + ')';
              const id = uniqueId('userreq_' + item.userReqNumber);
              const start = toEpochMs(item.startTime);
              const end = toEpochMs(item.endTime);
              lines.push('    ' + label + '    :milestone, ' + id + ', ' + start + ', ' + end);
            } else if (item.rowType === 'subagent') {
              const start = toEpochMs(item.startTime);
              const end = toEpochMs(item.endTime);
              const toolInfo = (item.toolCalls != null ? item.toolCalls : 0) + ' tools';
              const label = sanitize(item.name) + ' ‚Äì ' + formatDuration(item.duration) + ' (' + toolInfo + ')';
              const id = uniqueId(item.name);
              const tag = item.status === 'failed' ? 'crit, '
                : item.status === 'incomplete' ? 'active, ' : '';
              lines.push('    ' + label + '    :' + tag + id + ', ' + start + ', ' + end);
            } else if (item.rowType === 'main-agent') {
              const start = toEpochMs(item.startTime);
              const end = toEpochMs(item.endTime);
              const detail = sanitize(item.summary || 'idle');
              const label = 'Main Agent ‚Äì ' + formatDuration(item.duration) + ' (' + detail + ')';
              const id = uniqueId('main_agent');
              lines.push('    ' + label + '    :' + id + ', ' + start + ', ' + end);
            }
          }

          lines.push('```');
          lines.push('');

          const md = lines.join('\n');

          try {
            await navigator.clipboard.writeText(md);
            copyLabel.value = '‚úÖ Copied!';
          } catch (err) {
            // Fallback for non-secure contexts
            const textarea = document.createElement('textarea');
            textarea.value = md;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            copyLabel.value = '‚úÖ Copied!';
          }
          setTimeout(() => { copyLabel.value = 'üìä Copy as Mermaid Gantt'; }, 2000);
        };

        // ‰∫ã‰ª∂Ê†áËÆ∞Á±ªÂà´ÂÆö‰πâ
        const EVENT_MARKER_CATEGORIES = {
          'tool.execution_start':        { color: '#d29922', shape: 'diamond', label: 'Tool Start' },
          'tool.execution_complete':     { color: '#e3b341', shape: 'diamond', label: 'Tool Complete' },
          'assistant.message':           { color: '#8b949e', shape: 'circle',  label: 'Message' },
          'user.message':                { color: '#79c0ff', shape: 'square',  label: 'User Message' },
          'session.start':               { color: '#56d364', shape: 'square',  label: 'Session Start' },
          'session.resume':              { color: '#56d364', shape: 'square',  label: 'Session Resume' },
          'session.error':               { color: '#f85149', shape: 'triangle', label: 'Error' },
          'session.truncation':          { color: '#f0883e', shape: 'triangle', label: 'Truncation' },
          'session.compaction_start':    { color: '#a371f7', shape: 'square',  label: 'Compaction Start' },
          'session.compaction_complete': { color: '#bc8cff', shape: 'square',  label: 'Compaction End' },
          'session.model_change':        { color: '#f778ba', shape: 'square',  label: 'Model Change' },
          'abort':                       { color: '#ff7b72', shape: 'triangle', label: 'Abort' },
        };
        const TRACKABLE_EVENT_TYPES = new Set(Object.keys(EVENT_MARKER_CATEGORIES));

        // ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ
        const formatDuration = (ms) => {
          if (ms == null || ms < 0) return '‚Äî';
          if (ms < 1000) return Math.round(ms) + 'ms';
          const s = ms / 1000;
          if (s < 60) {
            const rounded = Math.round(s * 10) / 10; // ÂõõËàç‰∫îÂÖ•Âà∞‰∏Ä‰ΩçÂ∞èÊï∞
            return (rounded % 1 === 0 ? Math.round(rounded) : rounded.toFixed(1)) + 's';
          }
          const m = Math.floor(s / 60);
          const remainder = Math.floor(s % 60);
          if (m < 60) return m + 'm ' + remainder + 's';
          const h = Math.floor(m / 60);
          return h + 'h ' + (m % 60) + 'm';
        };

        const formatTime = (ts) => {
          if (!ts) return '';
          const d = new Date(ts);
          return String(d.getHours()).padStart(2, '0') + ':' +
                 String(d.getMinutes()).padStart(2, '0') + ':' +
                 String(d.getSeconds()).padStart(2, '0');
        };

        const formatDateTime = (ts) => {
          if (!ts) return '';
          return new Date(ts).toLocaleString();
        };

        // ‚îÄ‚îÄ Session timeline ‚îÄ‚îÄ
        const sessionStart = computed(() => {
          if (!events.value.length) return null;
          return new Date(events.value[0].timestamp).getTime();
        });

        const sessionEnd = computed(() => {
          if (!events.value.length) return null;
          return new Date(events.value[events.value.length - 1].timestamp).getTime();
        });

        const totalDuration = computed(() => {
          if (!sessionStart.value || !sessionEnd.value) return 0;
          return sessionEnd.value - sessionStart.value;
        });

        // ‚îÄ‚îÄ Shared sorted events (computed once, reused everywhere) ‚îÄ‚îÄ
        const sortedEvents = computed(() => {
          return [...events.value].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        });

        // ‚îÄ‚îÄ Sub-agent analysis ‚îÄ‚îÄ
        const subagentAnalysis = computed(() => {
          const sorted = sortedEvents.value;
          const results = [];
          const startStack = [];

          for (const ev of sorted) {
            if (ev.type === 'subagent.started') {
              startStack.push(ev);
            } else if (ev.type === 'subagent.completed' || ev.type === 'subagent.failed') {
              const name = ev.data?.agentDisplayName || ev.data?.agentName || 'SubAgent';
              // Find matching start (by name, LIFO)
              let startIdx = -1;
              for (let i = startStack.length - 1; i >= 0; i--) {
                const sName = startStack[i].data?.agentDisplayName || startStack[i].data?.agentName || 'SubAgent';
                if (sName === name) {
                  startIdx = i;
                  break;
                }
              }
              const startEv = startIdx >= 0 ? startStack.splice(startIdx, 1)[0] : null;
              const startTime = startEv ? new Date(startEv.timestamp).getTime() : null;
              const endTime = new Date(ev.timestamp).getTime();
              const duration = startTime ? endTime - startTime : null;

              // Count tool calls between start and end
              let toolCalls = 0;
              const innerEvents = [];
              if (startEv) {
                for (const e of sorted) {
                  const t = new Date(e.timestamp).getTime();
                  if (t >= startTime && t <= endTime) {
                    if (e.type === 'tool.execution_start') toolCalls++;
                    if (TRACKABLE_EVENT_TYPES.has(e.type)) {
                      innerEvents.push({ type: e.type, timestamp: t, data: e.data });
                    }
                  }
                }
              }

              // Build event markers with clustering
              const innerEventMarkers = buildEventMarkers(innerEvents, startTime, duration);

              results.push({
                name,
                status: ev.type === 'subagent.completed' ? 'completed' : 'failed',
                startTime: startEv?.timestamp || null,
                endTime: ev.timestamp,
                duration,
                toolCalls,
                innerEventMarkers
              });
            }
          }

          // Handle incomplete sub-agents (started but never completed/failed)
          const sessionEndTime = sorted.length > 0 ? new Date(sorted[sorted.length - 1].timestamp).getTime() : Date.now();
          for (const startEv of startStack) {
            const name = startEv.data?.agentDisplayName || startEv.data?.agentName || 'SubAgent';
            const startTime = new Date(startEv.timestamp).getTime();
            const duration = sessionEndTime - startTime;

            // Count tool calls after start
            let toolCalls = 0;
            const innerEvents = [];
            for (const e of sorted) {
              const t = new Date(e.timestamp).getTime();
              if (t >= startTime && t <= sessionEndTime) {
                if (e.type === 'tool.execution_start') toolCalls++;
                if (TRACKABLE_EVENT_TYPES.has(e.type)) {
                  innerEvents.push({ type: e.type, timestamp: t, data: e.data });
                }
              }
            }

            const innerEventMarkers = buildEventMarkers(innerEvents, startTime, duration);

            results.push({
              name,
              status: 'incomplete',
              startTime: startEv.timestamp,
              endTime: sorted[sorted.length - 1]?.timestamp || startEv.timestamp,
              duration,
              toolCalls,
              innerEventMarkers
            });
          }

          return results.sort((a, b) => {
            const tA = a.startTime ? new Date(a.startTime).getTime() : 0;
            const tB = b.startTime ? new Date(b.startTime).getTime() : 0;
            return tA - tB;
          });
        });

        const maxSubagentDuration = computed(() => {
          return Math.max(...subagentAnalysis.value.map(s => s.duration || 0), 1);
        });

        const subagentStats = computed(() => {
          const agents = subagentAnalysis.value;
          const completed = agents.filter(a => a.status === 'completed').length;
          const failed = agents.filter(a => a.status === 'failed').length;
          const incomplete = agents.filter(a => a.status === 'incomplete').length;
          const successRate = agents.length ? ((completed / agents.length) * 100).toFixed(0) : 100;

          // Merge overlapping intervals to get actual wall-clock time in subagents
          // and build merged interval list for tool counting (single pass)
          const intervals = agents
            .filter(a => a.startTime && a.endTime)
            .map(a => [new Date(a.startTime).getTime(), new Date(a.endTime).getTime()])
            .sort((a, b) => a[0] - b[0]);
          const mergedIntervals = [];
          for (const [s, e] of intervals) {
            if (!mergedIntervals.length || s >= mergedIntervals[mergedIntervals.length - 1].e) {
              mergedIntervals.push({ s, e });
            } else if (e > mergedIntervals[mergedIntervals.length - 1].e) {
              mergedIntervals[mergedIntervals.length - 1].e = e;
            }
          }
          const totalTime = mergedIntervals.reduce((sum, iv) => sum + (iv.e - iv.s), 0);

          // Count tool calls using merged intervals with binary search (O(n log k))
          let totalTools = 0;
          for (const ev of sortedEvents.value) {
            if (ev.type !== 'tool.execution_start') continue;
            const t = new Date(ev.timestamp).getTime();
            let lo = 0, hi = mergedIntervals.length - 1;
            while (lo <= hi) {
              const mid = (lo + hi) >> 1;
              if (t < mergedIntervals[mid].s) hi = mid - 1;
              else if (t > mergedIntervals[mid].e) lo = mid + 1;
              else { totalTools++; break; }
            }
          }

          return { completed, failed, incomplete, totalTime, totalTools, successRate };
        });

        // ‚îÄ‚îÄ Event marker builder (shared by subagent + agent-op) ‚îÄ‚îÄ
        const buildEventMarkers = (innerEvents, startTime, duration) => {
          if (!innerEvents.length || !duration) return [];

          // Separate high-priority events (always shown individually) from tool events (clustered)
          const HIGH_PRIORITY_TYPES = new Set([
            'session.start', 'session.resume', 'session.error',
            'session.truncation', 'session.compaction_start', 'session.compaction_complete',
            'session.model_change', 'abort', 'user.message',
          ]);

          const hiPriEvents = [];
          const toolEvents = [];
          for (const ev of innerEvents) {
            if (HIGH_PRIORITY_TYPES.has(ev.type)) {
              hiPriEvents.push(ev);
            } else {
              toolEvents.push(ev);
            }
          }

          // Build individual markers for high-priority events (never clustered)
          const hiPriMarkers = hiPriEvents.map(ev => {
            const relPos = ((ev.timestamp - startTime) / duration) * 100;
            const cat = EVENT_MARKER_CATEGORIES[ev.type] || {};
            return {
              type: ev.type,
              position: Math.max(0, Math.min(100, relPos)),
              color: cat.color || '#8b949e',
              shape: cat.shape || 'circle',
              label: cat.label || ev.type,
              timestamp: ev.timestamp,
              toolName: ev.data?.toolName || null,
            };
          });

          // Cluster tool events into fixed time buckets
          // Adaptive: aim for ~20 buckets max, with a minimum of 5 minutes per bucket
          const MIN_BUCKET_MS = 5 * 60 * 1000; // 5 minutes
          const bucketSize = Math.max(MIN_BUCKET_MS, duration / 20);

          const buckets = new Map(); // bucketIndex -> events[]
          for (const ev of toolEvents) {
            const bucketIdx = Math.floor((ev.timestamp - startTime) / bucketSize);
            if (!buckets.has(bucketIdx)) buckets.set(bucketIdx, []);
            buckets.get(bucketIdx).push(ev);
          }

          const toolMarkers = [];
          for (const [bucketIdx, group] of buckets) {
            const bucketMid = startTime + (bucketIdx + 0.5) * bucketSize;
            const relPos = ((bucketMid - startTime) / duration) * 100;
            const pos = Math.max(0, Math.min(100, relPos));

            if (group.length === 1) {
              const ev = group[0];
              const cat = EVENT_MARKER_CATEGORIES[ev.type] || {};
              toolMarkers.push({
                type: ev.type,
                position: pos,
                color: cat.color || '#8b949e',
                shape: cat.shape || 'circle',
                label: cat.label || ev.type,
                timestamp: ev.timestamp,
                toolName: ev.data?.toolName || null,
              });
            } else {
              // Summarize the cluster
              const typeCounts = {};
              group.forEach(ev => {
                const cat = EVENT_MARKER_CATEGORIES[ev.type] || {};
                const lbl = cat.label || ev.type;
                typeCounts[lbl] = (typeCounts[lbl] || 0) + 1;
              });
              const summaryParts = Object.entries(typeCounts).map(([l, c]) => c + ' ' + l);
              const dominantType = group.reduce((best, ev) => {
                const cnt = group.filter(e => e.type === ev.type).length;
                return cnt > best.cnt ? { type: ev.type, cnt } : best;
              }, { type: group[0].type, cnt: 0 }).type;
              const dominantCat = EVENT_MARKER_CATEGORIES[dominantType] || {};

              toolMarkers.push({
                type: 'cluster',
                position: pos,
                color: dominantCat.color || '#8b949e',
                shape: 'cluster',
                label: summaryParts.join(', '),
                count: group.length,
                items: group,
              });
            }
          }

          // Merge and sort by position
          return [...hiPriMarkers, ...toolMarkers].sort((a, b) => a.position - b.position);
        };

        // ‚îÄ‚îÄ Build Agent Operation item for gaps ‚îÄ‚îÄ
        const buildAgentOpItem = (sorted, gapStart, gapEnd) => {
          const duration = gapEnd - gapStart;
          const gapEvents = [];
          const eventCounts = {};
          for (const e of sorted) {
            const t = new Date(e.timestamp).getTime();
            if (t >= gapStart && t <= gapEnd) {
              if (TRACKABLE_EVENT_TYPES.has(e.type)) {
                gapEvents.push({ type: e.type, timestamp: t, data: e.data });
              }
              // Count by category for summary
              let cat = 'other';
              if (e.type.startsWith('tool.')) cat = 'tool';
              else if (e.type.startsWith('assistant.')) cat = 'message';
              else if (e.type.startsWith('user.')) cat = 'user';
              else if (e.type.startsWith('session.')) cat = 'session';
              eventCounts[cat] = (eventCounts[cat] || 0) + 1;
            }
          }

          // Build summary string
          const parts = [];
          if (eventCounts.tool) parts.push(eventCounts.tool + ' tool event' + (eventCounts.tool > 1 ? 's' : ''));
          if (eventCounts.message) parts.push(eventCounts.message + ' message' + (eventCounts.message > 1 ? 's' : ''));
          if (eventCounts.user) parts.push(eventCounts.user + ' user msg');
          if (eventCounts.session) parts.push(eventCounts.session + ' session event' + (eventCounts.session > 1 ? 's' : ''));
          if (eventCounts.other) parts.push(eventCounts.other + ' other');
          const summary = parts.length ? parts.join(', ') : 'idle';

          const innerEventMarkers = buildEventMarkers(gapEvents, gapStart, duration);

          return {
            itemType: 'agent-op',
            name: 'Main Agent',
            summary,
            startTime: new Date(gapStart).toISOString(),
            endTime: new Date(gapEnd).toISOString(),
            duration,
            eventCounts,
            innerEventMarkers,
          };
        };

        // ‚îÄ‚îÄ Subagent timeline items (subagent bars + agent-op gaps) ‚îÄ‚îÄ
        const subagentTimelineItems = computed(() => {
          const agents = subagentAnalysis.value;
          if (!agents.length) return [];

          const sorted = sortedEvents.value;
          const items = [];

          for (let i = 0; i < agents.length; i++) {
            const sa = agents[i];

            // Before first subagent: check gap from session start
            if (i === 0 && sa.startTime) {
              const gapStart = sessionStart.value;
              const gapEnd = new Date(sa.startTime).getTime();
              if (gapEnd - gapStart > 500) {
                items.push(buildAgentOpItem(sorted, gapStart, gapEnd));
              }
            }

            // Add subagent itself
            items.push({ ...sa, itemType: 'subagent' });

            // Gap between this and next subagent (or session end)
            const nextSa = agents[i + 1];
            const gapStart = new Date(sa.endTime).getTime();
            const gapEnd = nextSa
              ? new Date(nextSa.startTime).getTime()
              : sessionEnd.value;

            if (gapEnd - gapStart > 500) {
              items.push(buildAgentOpItem(sorted, gapStart, gapEnd));
            }
          }

          return items;
        });

        // ‚îÄ‚îÄ Turn analysis ‚îÄ‚îÄ
        const turnAnalysis = computed(() => {
          const sorted = sortedEvents.value;
          const turnStarts = sorted.filter(e => e.type === 'assistant.turn_start');
          const allUserMessages = sorted.filter(e => e.type === 'user.message');

          return turnStarts.map((turn, idx) => {
            const startTime = new Date(turn.timestamp).getTime();
            const nextTurn = turnStarts[idx + 1];
            const endTime = nextTurn
              ? new Date(nextTurn.timestamp).getTime()
              : sessionEnd.value || startTime;
            const duration = endTime - startTime;

            // Find user message before this turn
            const turnIndex = sorted.indexOf(turn);
            const userMessage = sorted
              .slice(0, turnIndex)
              .reverse()
              .find(e => e.type === 'user.message');

            const userReqNumber = userMessage
              ? allUserMessages.indexOf(userMessage) + 1
              : 0;

            // Count tool calls in this turn
            let toolCalls = 0;
            for (const e of sorted) {
              const t = new Date(e.timestamp).getTime();
              if (t >= startTime && t <= endTime && e.type === 'tool.execution_start') {
                toolCalls++;
              }
            }

            return {
              turnId: turn.data?.turnId ?? idx,
              userReqNumber,
              message: userMessage?.data?.content || userMessage?.data?.transformedContent || '',
              startTime: turn.timestamp,
              endTime: nextTurn?.timestamp || events.value[events.value.length - 1]?.timestamp,
              duration,
              toolCalls
            };
          });
        });

        const maxTurnDuration = computed(() => {
          return Math.max(...turnAnalysis.value.map(t => t.duration || 0), 1);
        });

        // ‚îÄ‚îÄ Grouped turns by UserReq ‚îÄ‚îÄ
        const groupedTurns = computed(() => {
          const groups = new Map();
          
          for (const turn of turnAnalysis.value) {
            const reqNum = turn.userReqNumber || 0;
            if (!groups.has(reqNum)) {
              groups.set(reqNum, {
                userReqNumber: reqNum,
                message: turn.message,
                turns: []
              });
            }
            groups.get(reqNum).turns.push(turn);
          }
          
          return Array.from(groups.values()).sort((a, b) => a.userReqNumber - b.userReqNumber);
        });

        // ‚îÄ‚îÄ Tool operations analysis ‚îÄ‚îÄ
        const toolAnalysis = computed(() => {
          const sorted = sortedEvents.value;
          const toolGroups = new Map();

          for (const ev of sorted) {
            if (ev.type === 'tool.execution_start') {
              const toolId = ev.data?.toolCallId;
              if (toolId) {
                toolGroups.set(toolId, { start: ev });
              }
            } else if (ev.type === 'tool.execution_complete') {
              const toolId = ev.data?.toolCallId;
              if (toolId && toolGroups.has(toolId)) {
                toolGroups.get(toolId).complete = ev;
              }
            }
          }

          const results = [];
          toolGroups.forEach((group, toolId) => {
            const startTime = new Date(group.start.timestamp).getTime();
            const endTime = group.complete
              ? new Date(group.complete.timestamp).getTime()
              : null;
            const duration = endTime ? endTime - startTime : null;
            const toolName = group.start.data?.toolName || group.start.data?.tool || 'unknown';
            const args = group.start.data?.arguments || {};
            const isError = group.complete?.data?.isError || !!group.complete?.data?.error;

            // Extract file path or command
            let description = '';
            if (toolName === 'Bash' || toolName === 'bash' || toolName === 'exec') {
              description = args.command || args.description || '';
            } else if (['Read', 'read', 'Write', 'write', 'Edit', 'edit'].includes(toolName)) {
              description = args.file_path || args.path || '';
            } else if (['Glob', 'glob'].includes(toolName)) {
              description = args.pattern || '';
            } else if (['Grep', 'grep'].includes(toolName)) {
              description = args.pattern || '';
            } else if (['Task', 'task'].includes(toolName)) {
              description = args.description || args.prompt?.substring(0, 80) || '';
            } else {
              description = args.description || args.command || args.file_path ||
                          args.path || args.query || args.url || '';
            }
            if (description.length > 120) {
              description = description.substring(0, 120) + '...';
            }

            results.push({
              toolId,
              toolName,
              description,
              startTime: group.start.timestamp,
              endTime: group.complete?.timestamp || null,
              duration,
              isError,
              isRunning: !group.complete
            });
          });

          return results;
        });

        const sortedToolAnalysis = computed(() => {
          const items = [...toolAnalysis.value];
          items.sort((a, b) => {
            if (sortField.value === 'duration') {
              return sortDir.value === 'asc'
                ? (a.duration || 0) - (b.duration || 0)
                : (b.duration || 0) - (a.duration || 0);
            }
            if (sortField.value === 'toolName') {
              const cmp = (a.toolName || '').localeCompare(b.toolName || '');
              return sortDir.value === 'asc' ? cmp : -cmp;
            }
            // default: timestamp
            const tA = new Date(a.startTime).getTime();
            const tB = new Date(b.startTime).getTime();
            return sortDir.value === 'asc' ? tA - tB : tB - tA;
          });
          return items;
        });

        const maxToolDuration = computed(() => {
          return Math.max(...toolAnalysis.value.map(t => t.duration || 0), 1);
        });

        // ‚îÄ‚îÄ File operations ‚îÄ‚îÄ
        const fileOperations = computed(() => {
          const fileTools = ['view', 'read', 'write', 'edit', 'create', 'glob', 'grep', 'notebookedit'];
          const ops = [];
          
          for (const ev of events.value) {
            if (ev.type === 'tool.execution_start') {
              const toolName = ev.data?.toolName?.toLowerCase() || '';
              if (fileTools.includes(toolName)) {
                const args = ev.data?.arguments || {};
                const path = args.path || args.file || args.directory || '';
                
                if (path) {
                  let opType = 'other';
                  if (toolName === 'view' || toolName === 'read') opType = 'read';
                  else if (toolName === 'write' || toolName === 'notebookedit' || toolName === 'create') opType = 'write';
                  else if (toolName === 'edit') opType = 'edit';
                  else if (toolName === 'glob' || toolName === 'grep') opType = 'search';
                  
                  ops.push({
                    toolName,
                    opType,
                    filePath: path,
                    timestamp: ev.timestamp,
                    startTime: ev.timestamp
                  });
                }
              }
            }
          }

          return ops.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        });

        const fileStats = computed(() => {
          const ops = fileOperations.value;
          const uniqueFiles = new Set(ops.map(o => o.filePath));
          return {
            uniqueCount: uniqueFiles.size,
            totalOps: ops.length,
            reads: ops.filter(o => o.opType === 'read').length,
            writes: ops.filter(o => o.opType === 'write').length,
            edits: ops.filter(o => o.opType === 'edit').length,
            searches: ops.filter(o => o.opType === 'search').length
          };
        });

        // ‚îÄ‚îÄ Tool time by category ‚îÄ‚îÄ
        const toolTimeByCategory = computed(() => {
          const catMap = {};
          toolAnalysis.value.forEach(t => {
            const name = (t.toolName || 'unknown').toLowerCase();
            let cat;
            if (['bash', 'exec'].includes(name)) cat = 'Bash/Exec';
            else if (['read'].includes(name)) cat = 'Read';
            else if (['write'].includes(name)) cat = 'Write';
            else if (['edit'].includes(name)) cat = 'Edit';
            else if (['glob'].includes(name)) cat = 'Glob';
            else if (['grep'].includes(name)) cat = 'Grep';
            else if (['task'].includes(name)) cat = 'Task (SubAgent)';
            else if (['web_search', 'websearch'].includes(name)) cat = 'Web Search';
            else if (['web_fetch', 'webfetch'].includes(name)) cat = 'Web Fetch';
            else cat = t.toolName || 'Other';

            if (!catMap[cat]) {
              catMap[cat] = { category: cat, totalTime: 0, count: 0, errors: 0 };
            }
            catMap[cat].totalTime += (t.duration || 0);
            catMap[cat].count++;
            if (t.isError) catMap[cat].errors++;
          });

          return Object.values(catMap).sort((a, b) => b.totalTime - a.totalTime);
        });

        const maxCategoryTime = computed(() => {
          return Math.max(...toolTimeByCategory.value.map(c => c.totalTime), 1);
        });

        // ‚îÄ‚îÄ Summary stats ‚îÄ‚îÄ
        // Wall-clock tool time: merge overlapping intervals to avoid double-counting parallel tools
        const totalToolTime = computed(() => {
          const intervals = toolAnalysis.value
            .filter(t => t.duration && t.startTime && t.endTime)
            .map(t => ({
              start: new Date(t.startTime).getTime(),
              end: new Date(t.endTime).getTime()
            }))
            .sort((a, b) => a.start - b.start);

          if (!intervals.length) return 0;

          // Merge overlapping intervals
          let totalMs = 0;
          let curStart = intervals[0].start;
          let curEnd = intervals[0].end;

          for (let i = 1; i < intervals.length; i++) {
            if (intervals[i].start <= curEnd) {
              // Overlapping ‚Äî extend current interval
              curEnd = Math.max(curEnd, intervals[i].end);
            } else {
              // Gap ‚Äî commit current interval and start new one
              totalMs += curEnd - curStart;
              curStart = intervals[i].start;
              curEnd = intervals[i].end;
            }
          }
          totalMs += curEnd - curStart; // commit last interval

          return totalMs;
        });

        // ‚îÄ‚îÄ Token Statistics ‚îÄ‚îÄ
        const tokenStats = computed(() => {
          let totalTokens = 0;
          let byCategory = {};
          
          for (const ev of events.value) {
            if (ev.type === 'tool.execution_complete' && ev.data?.toolTelemetry?.metrics) {
              const tokens = ev.data.toolTelemetry.metrics.resultForLlmLength || 0;
              totalTokens += tokens;
              
              // Categorize by tool name
              const toolName = ev.data.toolName || 'unknown';
              if (!byCategory[toolName]) {
                byCategory[toolName] = 0;
              }
              byCategory[toolName] += tokens;
            }
          }
          
          return {
            total: totalTokens,
            byCategory
          };
        });

        // ‚îÄ‚îÄ Gap Analysis ‚îÄ‚îÄ
        const gapAnalysis = computed(() => {
          const sorted = sortedEvents.value;
          const gaps = [];
          
          // Track user messages and assistant responses
          for (let i = 0; i < sorted.length - 1; i++) {
            const current = sorted[i];
            const next = sorted[i + 1];
            const currentTime = new Date(current.timestamp).getTime();
            const nextTime = new Date(next.timestamp).getTime();
            const duration = nextTime - currentTime;
            
            // Only report gaps > 100ms
            if (duration < 100) continue;
            
            let gapType = null;
            let description = '';
            
            // User message ‚Üí assistant.turn_start (input consumption)
            if (current.type === 'user.message' && next.type === 'assistant.turn_start') {
              gapType = 'input-consumption';
              const msgLength = (current.data?.message || '').length;
              description = `LLM reading user input (${msgLength} chars)`;
            }
            
            // assistant.turn_start ‚Üí assistant.message (generation)
            else if (current.type === 'assistant.turn_start' && next.type === 'assistant.message') {
              gapType = 'llm-generation';
              const outputLength = (next.data?.content || '').length;
              description = `LLM generating response (${outputLength} chars output)`;
            }
            
            // assistant.turn_start ‚Üí first tool (generation before tool call)
            else if (current.type === 'assistant.turn_start' && next.type === 'tool.execution_start') {
              gapType = 'llm-generation';
              const toolName = next.data?.toolName || 'unknown';
              description = `LLM deciding to call ${toolName}`;
            }
            
            // assistant.message ‚Üí assistant.turn_start (thinking between turns)
            else if (current.type === 'assistant.message' && next.type === 'assistant.turn_start') {
              gapType = 'turn-gap';
              description = 'Gap between assistant response and next turn';
            }
            
            // tool.execution_complete ‚Üí next event (post-processing)
            else if (current.type === 'tool.execution_complete' && duration > 500) {
              gapType = 'post-tool';
              const toolName = current.data?.toolName || 'unknown';
              description = `Processing ${toolName} result`;
            }
            
            // Large gaps between any events
            else if (duration > 5000) {
              gapType = 'idle';
              description = `${current.type} ‚Üí ${next.type}`;
            }
            
            if (gapType) {
              gaps.push({
                type: gapType,
                description,
                startTime: current.timestamp,
                endTime: next.timestamp,
                duration,
                fromEvent: current.type,
                toEvent: next.type,
                fromData: current.data,
                toData: next.data
              });
            }
          }
          
          return gaps.sort((a, b) => (b.duration || 0) - (a.duration || 0));
        });
        
        const maxGapDuration = computed(() => {
          return Math.max(...gapAnalysis.value.map(g => g.duration || 0), 1);
        });
        
        const gapStats = computed(() => {
          const stats = {
            'input-consumption': { count: 0, total: 0, avg: 0 },
            'llm-generation': { count: 0, total: 0, avg: 0 },
            'post-tool': { count: 0, total: 0, avg: 0 },
            'turn-gap': { count: 0, total: 0, avg: 0 },
            'idle': { count: 0, total: 0, avg: 0 }
          };
          
          gapAnalysis.value.forEach(gap => {
            if (stats[gap.type]) {
              stats[gap.type].count++;
              stats[gap.type].total += gap.duration;
            }
          });
          
          Object.keys(stats).forEach(key => {
            if (stats[key].count > 0) {
              stats[key].avg = stats[key].total / stats[key].count;
            }
          });
          
          return stats;
        });

        const successRate = computed(() => {
          const total = toolAnalysis.value.length;
          if (total === 0) return 100;
          const errors = toolAnalysis.value.filter(t => t.isError).length;
          return ((total - errors) / total * 100).toFixed(1);
        });

        const errorCount = computed(() => {
          return toolAnalysis.value.filter(t => t.isError).length;
        });

        // Time breakdown: user thinking vs agent working
        // "User thinking" = gaps where the agent has finished and is waiting for the next user message
        // "Agent working" = totalDuration - userThinkingTime
        const timeBreakdown = computed(() => {
          const sorted = sortedEvents.value;
          let userThinkingTime = 0;

          for (let i = 0; i < sorted.length - 1; i++) {
            const current = sorted[i];
            const next = sorted[i + 1];

            // User thinking = from any non-user event to the next user.message
            // This captures when the agent is done and waiting for the user to type
            if (next.type === 'user.message' && current.type !== 'user.message') {
              const gap = new Date(next.timestamp).getTime() - new Date(current.timestamp).getTime();
              if (gap > 1000) { // Only count gaps > 1s as intentional user thinking
                userThinkingTime += gap;
              }
            }
          }

          const total = totalDuration.value || 0;
          const agentWorkingTime = Math.max(total - userThinkingTime, 0);
          // LLM time = agent working time minus tool wall-clock time
          const llmTime = Math.max(agentWorkingTime - totalToolTime.value, 0);

          return {
            userThinkingTime,
            agentWorkingTime,
            llmTime,
            userThinkingPct: total > 0 ? (userThinkingTime / total * 100).toFixed(0) : 0,
            agentWorkingPct: total > 0 ? (agentWorkingTime / total * 100).toFixed(0) : 0,
          };
        });



        const totalToolCount = computed(() => toolAnalysis.value.length);

        const avgToolDuration = computed(() => {
          if (!totalToolCount.value) return 0;
          const rawSum = toolAnalysis.value.reduce((acc, t) => acc + (t.duration || 0), 0);
          return rawSum / totalToolCount.value;
        });

        const longestTool = computed(() => {
          if (!toolAnalysis.value.length) return null;
          return toolAnalysis.value.reduce((max, t) => (t.duration || 0) > (max.duration || 0) ? t : max);
        });

        // ‚îÄ‚îÄ Unified Timeline Items ‚îÄ‚îÄ
        const unifiedTimelineItems = computed(() => {
          const items = [];
          const groups = groupedTurns.value;
          const agents = subagentAnalysis.value;
          const sorted = sortedEvents.value;

          if (groups.length) {
            for (let gi = 0; gi < groups.length; gi++) {
              const group = groups[gi];
              const turns = group.turns;
              if (!turns.length) continue;

              const reqStart = new Date(turns[0].startTime).getTime();
              const reqEnd = new Date(turns[turns.length - 1].endTime).getTime();

              // 1. Push user-req header row
              items.push({
                rowType: 'user-req',
                userReqNumber: group.userReqNumber,
                message: group.message,
                startTime: turns[0].startTime,
                endTime: turns[turns.length - 1].endTime,
                duration: reqEnd - reqStart,
              });

              // 2. Find subagents within this UserReq time range
              const reqAgents = agents.filter(sa => {
                if (!sa.startTime) return false;
                const saStart = new Date(sa.startTime).getTime();
                return saStart >= reqStart && saStart <= reqEnd;
              });

              if (reqAgents.length) {
                // Build subagent + gap items scoped to this UserReq
                for (let i = 0; i < reqAgents.length; i++) {
                  const sa = reqAgents[i];

                  // Gap before first subagent (from reqStart) or between subagents
                  const gapStart = i === 0
                    ? reqStart
                    : new Date(reqAgents[i - 1].endTime).getTime();
                  const gapEnd = new Date(sa.startTime).getTime();

                  if (gapEnd - gapStart > 500) {
                    const agentOp = buildAgentOpItem(sorted, gapStart, gapEnd);
                    agentOp.rowType = 'main-agent';
                    items.push(agentOp);
                  }

                  // Add subagent
                  items.push({
                    ...sa,
                    rowType: 'subagent',
                    itemType: 'subagent',
                  });

                  // Gap after last subagent to reqEnd
                  if (i === reqAgents.length - 1) {
                    const trailingStart = new Date(sa.endTime).getTime();
                    const trailingEnd = reqEnd;
                    if (trailingEnd - trailingStart > 500) {
                      const agentOp = buildAgentOpItem(sorted, trailingStart, trailingEnd);
                      agentOp.rowType = 'main-agent';
                      items.push(agentOp);
                    }
                  }
                }
              } else {
                // No subagents ‚Äî show single Main Agent bar spanning entire UserReq
                if (reqEnd - reqStart > 0) {
                  const agentOp = buildAgentOpItem(sorted, reqStart, reqEnd);
                  agentOp.rowType = 'main-agent';
                  items.push(agentOp);
                }
              }
            }
          } else if (subagentTimelineItems.value.length) {
            // No UserReq groups, but subagents exist ‚Äî flat fallback
            for (const item of subagentTimelineItems.value) {
              items.push({
                ...item,
                rowType: item.itemType === 'agent-op' ? 'main-agent' : 'subagent',
              });
            }
          }

          // Tool summary section
          const cats = toolTimeByCategory.value;
          if (cats.length) {
            items.push({ rowType: 'divider' });

            // Compute maxTime for proportional bars
            const maxTime = Math.max(...cats.map(c => c.totalTime), 1);
            for (const cat of cats) {
              items.push({
                rowType: 'tool-summary',
                category: cat.category,
                count: cat.count,
                totalTime: cat.totalTime,
                errors: cat.errors,
                barWidthPct: (cat.totalTime / maxTime) * 100,
              });
            }
          }

          return items;
        });

        // ‚îÄ‚îÄ Gantt chart positioning ‚îÄ‚îÄ
        const ganttPosition = (startTs, endTs) => {
          if (!sessionStart.value || !totalDuration.value || !startTs) return { left: '0%', width: '0%' };
          const s = new Date(startTs).getTime();
          const e = endTs ? new Date(endTs).getTime() : s + 1000;
          const left = ((s - sessionStart.value) / totalDuration.value) * 100;
          const width = Math.max(((e - s) / totalDuration.value) * 100, 0.5);
          return {
            left: left + '%',
            width: Math.min(width, 100 - left) + '%'
          };
        };

        // ‚îÄ‚îÄ Sort control ‚îÄ‚îÄ
        const toggleSort = (field) => {
          if (sortField.value === field) {
            sortDir.value = sortDir.value === 'asc' ? 'desc' : 'asc';
          } else {
            sortField.value = field;
            sortDir.value = field === 'duration' ? 'desc' : 'asc';
          }
        };

        const sortIcon = (field) => {
          if (sortField.value !== field) return '‚Üï';
          return sortDir.value === 'asc' ? '‚Üë' : '‚Üì';
        };

        const getToolBadgeClass = (toolName) => {
          const lower = (toolName || '').toLowerCase();
          if (['bash', 'exec'].includes(lower)) return 'badge-bash';
          if (lower === 'read') return 'badge-read';
          if (lower === 'write' || lower === 'notebookedit') return 'badge-write';
          if (lower === 'edit') return 'badge-edit';
          if (lower === 'glob' || lower === 'grep') return 'badge-search';
          if (lower === 'task') return 'badge-subagent';
          return 'badge-other';
        };

        const getOpBadgeClass = (opType) => {
          const classes = {
            read: 'badge-read',
            write: 'badge-write',
            edit: 'badge-edit',
            create: 'badge-create',
            search: 'badge-search'
          };
          return classes[opType] || 'badge-other';
        };

        // ‚îÄ‚îÄ Load events ‚îÄ‚îÄ
        onMounted(async () => {
          try {
            const resp = await fetch('/api/sessions/' + sessionId.value + '/events');
            if (!resp.ok) throw new Error('Failed to load events: ' + resp.statusText);
            const data = await resp.json();
            events.value = data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
          } catch (err) {
            error.value = err.message;
          } finally {
            loading.value = false;
          }
        });

        // ‚îÄ‚îÄ Copilot Insight ‚îÄ‚îÄ
        const insightStatus = ref('not_started'); // completed | generating | timeout | not_started
        const insightLastUpdate = ref(null);
        const insightStartedAt = ref(null);
        const insightAgeMs = ref(0);
        let pollInterval = null;
        
        const renderedInsight = computed(() => {
          if (!insightReport.value) return '';
          return marked.parse(insightReport.value);
        });

        const checkExistingInsight = async () => {
          try {
            const resp = await fetch(`/session/${sessionId.value}/insight`);
            const data = await resp.json();

            insightStatus.value = data.status;

            if (data.status === 'completed') {
              insightReport.value = data.report;
              insightLog.value = null;
              insightGeneratedAt.value = data.generatedAt;
              stopPolling();
            } else if (data.status === 'generating') {
              insightLog.value = data.log || null;
              insightStartedAt.value = data.startedAt;
              insightLastUpdate.value = data.lastUpdate;
              insightAgeMs.value = data.ageMs;
              startPolling();
              // Auto-scroll log to bottom
              Vue.nextTick(() => {
                const el = document.getElementById('insight-log');
                if (el) el.scrollTop = el.scrollHeight;
              });
            } else if (data.status === 'timeout') {
              insightLog.value = data.log || null;
              insightStartedAt.value = data.startedAt;
              insightLastUpdate.value = data.lastUpdate;
              insightAgeMs.value = data.ageMs;
              // Keep polling ‚Äî the process may still finish and write the report
              startPolling();
            }
          } catch (err) {
            console.error('Failed to check insight:', err);
          }
        };
        
        const startPolling = () => {
          stopPolling();
          pollInterval = setInterval(checkExistingInsight, 2000); // Poll every 2 seconds
        };
        
        const stopPolling = () => {
          if (pollInterval) {
            clearInterval(pollInterval);
            pollInterval = null;
          }
        };

        const generateInsight = async (force = false) => {
          insightLoading.value = true;
          insightError.value = null;
          insightLog.value = null;

          try {
            const resp = await fetch(`/session/${sessionId.value}/insight`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ force })
            });

            if (!resp.ok) {
              const err = await resp.json();
              throw new Error(err.error || 'Failed to generate insight');
            }

            const data = await resp.json();
            insightStatus.value = data.status;

            if (data.status === 'generating') {
              insightStartedAt.value = data.startedAt;
              startPolling();
            } else if (data.status === 'completed') {
              insightReport.value = data.report;
              insightGeneratedAt.value = data.generatedAt;
            }
          } catch (err) {
            insightError.value = err.message;
          } finally {
            insightLoading.value = false;
          }
        };

        const regenerateInsight = async () => {
          await generateInsight(true);
        };

        // Check for existing insight on mount
        onMounted(async () => {
          await checkExistingInsight();
        });
        
        // Clean up polling on unmount
        onUnmounted(() => {
          stopPolling();
        });

        return {
          sessionId, metadata, events, loading, error, activeTab,
          sortField, sortDir,
          insightReport, insightLog, insightLoading, insightError, insightGeneratedAt,
          insightStatus, insightLastUpdate, insightStartedAt, insightAgeMs,
          renderedInsight, generateInsight, regenerateInsight,
          formatDuration, formatTime, formatDateTime,
          sessionStart, sessionEnd, totalDuration,
          subagentAnalysis, maxSubagentDuration, subagentTimelineItems, subagentStats,
          EVENT_MARKER_CATEGORIES, showMarkerLegend,
          copyLabel, copyTimelineMarkdown,
          turnAnalysis, maxTurnDuration, groupedTurns,
          unifiedTimelineItems,
          toolAnalysis, sortedToolAnalysis, maxToolDuration,
          fileOperations, fileStats,
          toolTimeByCategory, maxCategoryTime,
          totalToolTime, totalToolCount, avgToolDuration, longestTool,
          successRate, errorCount, timeBreakdown,
          gapAnalysis, maxGapDuration, gapStats,
          ganttPosition, toggleSort, sortIcon,
          getToolBadgeClass, getOpBadgeClass
        };
      },

      template: `
        <div v-if="loading" class="empty-state" style="padding: 60px;">
          ‚è≥ Loading events...
        </div>

        <div v-else-if="error" class="empty-state" style="padding: 60px; color: #f85149;">
          ‚ùå {{ error }}
        </div>

        <div v-else>
          <!-- Summary Cards -->
          <div class="summary-grid">
            <div class="summary-card">
              <div class="summary-card-label">Total Duration</div>
              <div class="summary-card-value">{{ formatDuration(totalDuration) }}</div>
              <div class="summary-card-sub">
                LLM {{ formatDuration(timeBreakdown.llmTime) }}
                ¬∑ Tools {{ formatDuration(totalToolTime) }}
                <span v-if="timeBreakdown.userThinkingTime > 1000"> ¬∑ User {{ formatDuration(timeBreakdown.userThinkingTime) }}</span>
              </div>
            </div>
            <div class="summary-card">
              <div class="summary-card-label">User Requests</div>
              <div class="summary-card-value">{{ groupedTurns.length }}</div>
              <div class="summary-card-sub">{{ turnAnalysis.length }} turn{{ turnAnalysis.length !== 1 ? 's' : '' }}</div>
            </div>
            <div class="summary-card">
              <div class="summary-card-label">Tool Calls</div>
              <div class="summary-card-value">{{ totalToolCount }}</div>
              <div class="summary-card-sub">
                <span :style="{ color: successRate >= 95 ? '#3fb950' : successRate >= 80 ? '#d29922' : '#f85149' }">{{ successRate }}%</span> success
                <span v-if="errorCount > 0" style="color: #f85149;"> ¬∑ {{ errorCount }} error{{ errorCount !== 1 ? 's' : '' }}</span>
              </div>
            </div>
            <div class="summary-card">
              <div class="summary-card-label">Sub-Agents</div>
              <div class="summary-card-value">{{ subagentAnalysis.length }}</div>
              <div class="summary-card-sub">
                <span :style="{ color: subagentStats.successRate >= 95 ? '#3fb950' : subagentStats.successRate >= 80 ? '#d29922' : '#f85149' }">{{ subagentStats.completed }}‚úì</span>
                <span v-if="subagentStats.failed > 0" style="color: #f85149;"> ¬∑ {{ subagentStats.failed }}‚úó</span>
                <span v-if="subagentStats.incomplete > 0" style="color: #d29922;"> ¬∑ {{ subagentStats.incomplete }}‚è≥</span>
                ¬∑ {{ formatDuration(subagentStats.totalTime) }}
                ¬∑ {{ subagentStats.totalTools }} tools
              </div>
            </div>
            <div class="summary-card">
              <div class="summary-card-label">File Operations</div>
              <div class="summary-card-value">{{ fileStats.totalOps }}</div>
              <div class="summary-card-sub">
                {{ fileStats.reads }} reads ¬∑ {{ fileStats.edits }} edits ¬∑ {{ fileStats.writes }} writes ¬∑ {{ fileStats.searches }} searches
              </div>
            </div>
          </div>

          <!-- Tabs -->
          <div class="tabs">
            <button :class="['tab', { active: activeTab === 'timeline' }]" @click="activeTab = 'timeline'">
              üìä Timeline
            </button>
            <button :class="['tab', { active: activeTab === 'insight' }]" @click="activeTab = 'insight'">
              üí° Agent Review
            </button>
          </div>

          <!-- ‚ïê‚ïê‚ïê Unified Timeline Tab ‚ïê‚ïê‚ïê -->
          <div v-if="activeTab === 'timeline'" class="section">
            <div v-if="!unifiedTimelineItems.length" class="empty-state">
              No timeline data found in this session.
            </div>
            <div v-else>
              <!-- Section A: Gantt Chart -->
              <div class="section-title" style="display: flex; align-items: center;">
                Timeline
                <button class="legend-toggle-btn" @click="showMarkerLegend = !showMarkerLegend">
                  {{ showMarkerLegend ? 'Hide Legend' : 'Show Legend' }}
                </button>
                <button class="legend-toggle-btn" @click="copyTimelineMarkdown">
                  {{ copyLabel }}
                </button>
              </div>

              <!-- Event Legend -->
              <div v-show="showMarkerLegend" class="event-legend">
                <div class="event-legend-item">
                  <span class="event-legend-swatch" style="background: rgba(88, 166, 255, 0.5);"></span>
                  <span>User Request</span>
                </div>
                <div class="event-legend-item">
                  <span class="event-legend-swatch" style="background: rgba(63, 185, 80, 0.8);"></span>
                  <span>Sub-Agent</span>
                </div>
                <div class="event-legend-item">
                  <span class="event-legend-swatch" style="background: rgba(139, 148, 158, 0.3); border: 1px dashed rgba(139, 148, 158, 0.5);"></span>
                  <span>Main Agent</span>
                </div>
                <div class="event-legend-item">
                  <span class="event-legend-swatch" style="background: rgba(158, 106, 3, 0.6);"></span>
                  <span>Tool Category</span>
                </div>
                <div v-for="(cat, type) in EVENT_MARKER_CATEGORIES" :key="type" class="event-legend-item">
                  <span class="event-legend-swatch" :style="{ background: cat.color, borderRadius: cat.shape === 'circle' ? '50%' : cat.shape === 'diamond' ? '1px' : '2px', transform: cat.shape === 'diamond' ? 'rotate(45deg)' : 'none' }"></span>
                  <span>{{ cat.label }}</span>
                </div>
              </div>

              <div class="gantt-container">
                <template v-for="(item, idx) in unifiedTimelineItems" :key="'utl-' + idx">

                  <!-- Divider row -->
                  <div v-if="item.rowType === 'divider'" class="gantt-divider">
                    Tool Summary
                  </div>

                  <!-- User Request row -->
                  <div v-else-if="item.rowType === 'user-req'" class="gantt-row">
                    <div class="gantt-label user-req" :title="item.message || 'No message'">
                      <span class="user-req-badge">UserReq {{ item.userReqNumber }}</span>
                      <span class="user-req-msg">{{ (item.message || '').substring(0, 40) }}{{ (item.message || '').length > 40 ? '...' : '' }}</span>
                    </div>
                    <div class="gantt-bar-area">
                      <div
                        class="gantt-bar user-req"
                        :style="ganttPosition(item.startTime, item.endTime)"
                        :title="'UserReq ' + item.userReqNumber + ' ‚Äî ' + formatDuration(item.duration)"
                      >
                        {{ formatDuration(item.duration) }}
                      </div>
                    </div>
                  </div>

                  <!-- Sub-Agent row (indented) -->
                  <div v-else-if="item.rowType === 'subagent'" class="gantt-row indented">
                    <div class="gantt-label" :title="item.name">
                      <a
                        :href="'/session/' + sessionId + '?eventType=subagent.started&eventName=' + encodeURIComponent(item.name) + '&eventTimestamp=' + encodeURIComponent(item.startTime || '')"
                        class="subagent-link"
                        :title="'View events from here'"
                      >
                        <span :style="{ color: item.status === 'completed' ? '#3fb950' : item.status === 'failed' ? '#f85149' : '#d29922' }">
                          {{ item.status === 'completed' ? '‚úì' : item.status === 'failed' ? '‚úó' : '‚è≥' }}
                        </span>
                        {{ item.name }}
                      </a>
                    </div>
                    <div class="gantt-bar-area">
                      <div
                        :class="['gantt-bar', item.status === 'completed' ? 'subagent' : item.status === 'failed' ? 'subagent-failed' : 'subagent-incomplete']"
                        :style="ganttPosition(item.startTime, item.endTime)"
                        :title="item.name + ' ‚Äî ' + formatDuration(item.duration)"
                      >
                        {{ formatDuration(item.duration) }}

                        <!-- Event markers -->
                        <template v-if="item.innerEventMarkers && item.innerEventMarkers.length">
                          <span
                            v-for="(marker, midx) in item.innerEventMarkers"
                            :key="'m-' + midx"
                            class="event-marker"
                            :style="{ left: marker.position + '%' }"
                          >
                            <template v-if="marker.shape === 'cluster'">
                              <span class="event-marker--cluster" :style="{ background: marker.color }">{{ marker.count }}</span>
                            </template>
                            <template v-else-if="marker.shape === 'circle'">
                              <span class="event-marker--circle" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'diamond'">
                              <span class="event-marker--diamond" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'square'">
                              <span class="event-marker--square" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'triangle'">
                              <span class="event-marker--triangle" :style="{ color: marker.color }"></span>
                            </template>
                            <span class="event-marker-tooltip">
                              <template v-if="marker.shape === 'cluster'">{{ marker.count }} events: {{ marker.label }}</template>
                              <template v-else>{{ marker.label }}<span v-if="marker.toolName"> ({{ marker.toolName }})</span></template>
                            </span>
                          </span>
                        </template>
                      </div>
                    </div>
                  </div>

                  <!-- Main Agent gap row (indented) -->
                  <div v-else-if="item.rowType === 'main-agent'" class="gantt-row indented">
                    <div class="gantt-label agent-op" :title="item.summary">
                      <span class="agent-op-icon">‚öô</span>
                      <span>Main Agent</span>
                      <span class="agent-op-summary">{{ item.summary }}</span>
                    </div>
                    <div class="gantt-bar-area">
                      <div
                        class="gantt-bar agent-op"
                        :style="ganttPosition(item.startTime, item.endTime)"
                        :title="'Main Agent ‚Äî ' + formatDuration(item.duration)"
                      >
                        {{ formatDuration(item.duration) }}

                        <!-- Event markers -->
                        <template v-if="item.innerEventMarkers && item.innerEventMarkers.length">
                          <span
                            v-for="(marker, midx) in item.innerEventMarkers"
                            :key="'m-' + midx"
                            class="event-marker"
                            :style="{ left: marker.position + '%' }"
                          >
                            <template v-if="marker.shape === 'cluster'">
                              <span class="event-marker--cluster" :style="{ background: marker.color }">{{ marker.count }}</span>
                            </template>
                            <template v-else-if="marker.shape === 'circle'">
                              <span class="event-marker--circle" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'diamond'">
                              <span class="event-marker--diamond" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'square'">
                              <span class="event-marker--square" :style="{ background: marker.color }"></span>
                            </template>
                            <template v-else-if="marker.shape === 'triangle'">
                              <span class="event-marker--triangle" :style="{ color: marker.color }"></span>
                            </template>
                            <span class="event-marker-tooltip">
                              <template v-if="marker.shape === 'cluster'">{{ marker.count }} events: {{ marker.label }}</template>
                              <template v-else>{{ marker.label }}<span v-if="marker.toolName"> ({{ marker.toolName }})</span></template>
                            </span>
                          </span>
                        </template>
                      </div>
                    </div>
                  </div>

                  <!-- Tool Summary row -->
                  <div v-else-if="item.rowType === 'tool-summary'" class="gantt-row">
                    <div class="gantt-label tool-summary" :title="item.category + ' (' + item.count + ' calls)'">
                      <span class="tool-cat-icon">üîß</span>
                      {{ item.category }}
                      <span class="tool-cat-count">({{ item.count }})</span>
                    </div>
                    <div class="gantt-bar-area">
                      <div
                        class="gantt-bar tool-summary"
                        :style="{ left: '0%', width: item.barWidthPct + '%' }"
                        :title="item.category + ' ‚Äî ' + formatDuration(item.totalTime) + ' (' + item.count + ' calls)'"
                      >
                        {{ formatDuration(item.totalTime) }}
                      </div>
                    </div>
                  </div>

                </template>

                <div class="gantt-time-axis">
                  <span>{{ formatTime(events[0]?.timestamp) }}</span>
                  <span>{{ formatTime(events[events.length-1]?.timestamp) }}</span>
                </div>
              </div>

            </div>
          </div>

          <!-- ‚ïê‚ïê‚ïê Copilot Insight Tab ‚ïê‚ïê‚ïê -->
          <div v-if="activeTab === 'insight'" class="section">
            <!-- Error State -->
            <div v-if="insightError" class="empty-state" style="padding: 60px; color: #f85149;">
              ‚ùå {{ insightError }}
            </div>

            <!-- Generating State -->
            <div v-else-if="insightStatus === 'generating'" style="padding: 20px;">
              <div :style="{
                background: '#0d1117',
                border: '1px solid ' + (insightAgeMs > 300000 ? '#d29922' : '#30363d'),
                borderRadius: '6px',
                padding: '20px',
                marginBottom: '20px',
              }">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                  <div style="display: flex; align-items: center;">
                    <span style="font-size: 24px; margin-right: 10px;">‚è≥</span>
                    <div>
                      <div style="font-weight: 600; color: #58a6ff; margin-bottom: 5px;">
                        Generating Agent Review...
                      </div>
                      <div style="font-size: 13px; color: #7d8590;">
                        Started: {{ formatDateTime(insightStartedAt) }} ‚Ä¢
                        Age: {{ Math.floor(insightAgeMs / 1000) }}s
                      </div>
                    </div>
                  </div>
                  <button
                    v-if="insightAgeMs > 300000"
                    @click="regenerateInsight"
                    style="
                      background: #d29922;
                      color: #fff;
                      border: none;
                      padding: 8px 16px;
                      border-radius: 6px;
                      font-size: 13px;
                      cursor: pointer;
                      font-weight: 500;
                      white-space: nowrap;
                    "
                    @mouseover="$event.target.style.background='#e3b341'"
                    @mouseleave="$event.target.style.background='#d29922'"
                  >
                    üîÑ Stop &amp; Retry
                  </button>
                </div>
                <!-- Slow generation warning -->
                <div v-if="insightAgeMs > 300000" style="
                  background: rgba(210, 153, 34, 0.1);
                  border: 1px solid rgba(210, 153, 34, 0.3);
                  border-radius: 6px;
                  padding: 10px 14px;
                  margin-bottom: 12px;
                  font-size: 13px;
                  color: #d29922;
                ">
                  ‚ö†Ô∏è Generation is taking longer than 5 minutes. For large sessions this is normal ‚Äî the agent needs to read and analyze all events. If it appears stuck, you can click <strong>Stop &amp; Retry</strong> to cancel and start fresh.
                </div>
                <div v-if="insightLog" id="insight-log" style="
                  background: #161b22;
                  border: 1px solid #30363d;
                  border-radius: 6px;
                  padding: 14px 16px;
                  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
                  font-size: 12px;
                  line-height: 1.6;
                  color: #8b949e;
                  white-space: pre-wrap;
                  word-break: break-word;
                  max-height: 400px;
                  overflow-y: auto;
                ">{{ insightLog }}</div>
              </div>
            </div>

            <!-- Timeout State -->
            <div v-else-if="insightStatus === 'timeout'" style="padding: 20px;">
              <div style="
                background: #0d1117;
                border: 1px solid #d29922;
                border-radius: 6px;
                padding: 20px;
                margin-bottom: 20px;
              ">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                  <div style="display: flex; align-items: center;">
                    <span style="font-size: 24px; margin-right: 10px;">‚è≥</span>
                    <div>
                      <div style="font-weight: 600; color: #d29922; margin-bottom: 5px;">
                        Still generating... ({{ Math.floor(insightAgeMs / 1000 / 60) }}m elapsed)
                      </div>
                      <div style="font-size: 13px; color: #7d8590;">
                        Large sessions with sub-agents may take 10‚Äì15 minutes. Still polling for completion.
                      </div>
                    </div>
                  </div>
                  <button
                    @click="regenerateInsight"
                    style="
                      background: #d29922;
                      color: #fff;
                      border: none;
                      padding: 8px 16px;
                      border-radius: 6px;
                      font-size: 13px;
                      cursor: pointer;
                      font-weight: 500;
                      white-space: nowrap;
                    "
                    @mouseover="$event.target.style.background='#e3b341'"
                    @mouseleave="$event.target.style.background='#d29922'"
                  >
                    üîÑ Stop &amp; Retry
                  </button>
                </div>
                <div v-if="insightLog" style="
                  background: #161b22;
                  border: 1px solid #30363d;
                  border-radius: 6px;
                  padding: 14px 16px;
                  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
                  font-size: 12px;
                  line-height: 1.6;
                  color: #8b949e;
                  white-space: pre-wrap;
                  word-break: break-word;
                  max-height: 400px;
                  overflow-y: auto;
                ">{{ insightLog }}</div>
              </div>
            </div>

            <!-- Not Started State -->
            <div v-else-if="insightStatus === 'not_started'" style="padding: 40px; text-align: center;">
              <p style="margin-bottom: 20px; color: #7d8590;">
                Generate an AI-powered quality & performance review of how the agent used its tools, prompts, and workflow in this session
              </p>
              <button
                @click="generateInsight(false)"
                :disabled="insightLoading"
                style="
                  background: #238636;
                  color: #fff;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 6px;
                  font-size: 14px;
                  cursor: pointer;
                  font-weight: 500;
                "
                @mouseover="$event.target.style.background='#2ea043'"
                @mouseleave="$event.target.style.background='#238636'"
              >
                üí° Generate Agent Review
              </button>
              <p style="margin-top: 12px; font-size: 12px; color: #6e7681;">
                For large sessions this may take several minutes ‚Äî you'll see a live progress log while the review is being generated.
              </p>
            </div>

            <!-- Completed State -->
            <div v-else-if="insightStatus === 'completed'" style="padding: 20px;">
              <div style="
                background: #161b22;
                border: 1px solid #30363d;
                border-radius: 6px;
                padding: 20px;
                margin-bottom: 20px;
              ">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                  <span style="color: #7d8590; font-size: 13px;">
                    Generated: {{ formatDateTime(insightGeneratedAt) }}
                  </span>
                  <button 
                    @click="regenerateInsight"
                    style="
                      background: transparent;
                      color: #58a6ff;
                      border: 1px solid #58a6ff;
                      padding: 5px 12px;
                      border-radius: 6px;
                      font-size: 12px;
                      cursor: pointer;
                    "
                    @mouseover="$event.target.style.background='rgba(88, 166, 255, 0.1)'"
                    @mouseleave="$event.target.style.background='transparent'"
                  >
                    üîÑ Regenerate
                  </button>
                </div>
                <div v-html="renderedInsight" style="
                  color: #c9d1d9;
                  line-height: 1.6;
                "></div>
              </div>
            </div>
          </div>
        </div>
      `
    });

    app.mount('#app');
  </script>
</body>
</html>
