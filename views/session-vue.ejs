<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session <%= sessionId %> - Vue Virtual Scroller</title>
  
  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3.5.28/dist/vue.global.prod.js" integrity="sha384-EyKhbIJoP1t1fKIFRNEfYKy4uy8qxs7UNS4Cab53xyXqCTUB1PCoxeFsD0G/NX9W" crossorigin="anonymous"></script>

  <!-- vue-virtual-scroller -->
  <link rel="stylesheet" href="https://unpkg.com/vue-virtual-scroller@2.0.0-beta.8/dist/vue-virtual-scroller.css" integrity="sha384-PIWxQLH13FE3yKn8YrBWCcBRMkCKr2xW0XcqY9sNVhmihrqyXrdsWrcjZdqlnaWg" crossorigin="anonymous">
  <script src="https://unpkg.com/vue-virtual-scroller@2.0.0-beta.8/dist/vue-virtual-scroller.min.js" integrity="sha384-asaCxaI3GxogQlKm59ynOPR3hwB7hNOTYipFrlNUHdRM0BOQs5BRO8ix8clxlj6p" crossorigin="anonymous"></script>

  <!-- Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      line-height: 1.5;
      overflow: hidden;
    }
    .container { 
      max-width: 100%; 
      height: 100vh; 
      display: flex;
      flex-direction: column;
      padding: 0;
    }
    
    /* Focus indicators for accessibility */
    button:focus-visible,
    input:focus-visible,
    .turn-btn:focus-visible,
    .filter-dropdown-toggle:focus-visible {
      outline: 2px solid #58a6ff;
      outline-offset: 2px;
      box-shadow: 0 0 0 4px rgba(88, 166, 255, 0.2);
    }
    
    /* Header */
    .header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .home-btn {
      padding: 6px 12px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      text-decoration: none;
      font-size: 14px;
      transition: all 0.2s;
    }
    .home-btn:hover {
      background: #30363d;
      border-color: #58a6ff;
    }
    .time-analyze-btn {
      padding: 6px 12px;
      background: #1f6feb;
      border: 1px solid #388bfd;
      border-radius: 6px;
      color: #fff;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .time-analyze-btn:hover {
      background: #388bfd;
      border-color: #58a6ff;
    }
    .export-btn {
      padding: 6px 12px;
      background: #238636;
      border: 1px solid #2ea043;
      border-radius: 6px;
      color: #fff;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .export-btn:hover:not(:disabled) {
      background: #2ea043;
      border-color: #3fb950;
    }
    .export-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    h1 { 
      color: #58a6ff; 
      font-size: 20px; 
      margin: 0;
      flex: 1;
    }
    
    /* Main layout */
    .main-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    /* Sidebar */
    .sidebar {
      width: 320px;
      flex-shrink: 0;
      background: #161b22;
      border-right: 1px solid #30363d;
      overflow-y: auto;
      padding: 16px;
      transition: all 0.3s ease;
      position: relative;
      z-index: 10;
    }
    .sidebar.collapsed {
      width: 0;
      padding: 0;
      border-right: none;
      overflow: hidden;
    }
    
    /* Sidebar toggle */
    .sidebar-toggle {
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #c9d1d9;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 14px;
      transition: all 0.2s;
    }
    .sidebar-toggle:hover {
      background: #30363d;
      color: #58a6ff;
    }
    
    /* Sidebar sections */
    .sidebar-section {
      margin-bottom: 20px;
    }
    .sidebar-section-title {
      font-size: 12px;
      font-weight: 600;
      color: #c9d1d9;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Session Info */
    .session-info {
      font-size: 13px;
    }
    .session-summary-block {
      color: #e6edf3;
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 12px;
      word-break: break-word;
      overflow-wrap: anywhere;
      display: -webkit-box;
      -webkit-line-clamp: 5;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    
    /* Session info table */
    .session-info-table {
      width: 100%;
      font-size: 12px;
    }
    .session-info-table td {
      padding: 6px 8px;
      border-bottom: 1px solid rgba(110, 118, 129, 0.15);
      vertical-align: top;
    }
    .session-info-table td:first-child {
      color: #8b949e;
      font-weight: 500;
      white-space: nowrap;
      width: 85px;
    }
    .session-info-table td:last-child {
      color: #c9d1d9;
      word-break: break-all;
    }
    .session-info-table tr:last-child td {
      border-bottom: none;
    }

    /* Source badges */
    .source-badge {
      display: inline-block;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .source-cli {
      background: rgba(35, 134, 54, 0.2);
      color: #3fb950;
      border: 1px solid rgba(35, 134, 54, 0.4);
    }
    .source-vscode {
      background: rgba(31, 111, 235, 0.2);
      color: #58a6ff;
      border: 1px solid rgba(31, 111, 235, 0.4);
    }
    
    /* Turn buttons */
    .turn-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .turn-btn {
      padding: 12px 10px;
      min-height: 44px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #c9d1d9;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      width: 100%;
      margin-bottom: 10px;
    }
    .turn-btn-id {
      font-weight: 600;
      color: #c9d1d9;
      font-size: 12px;
    }
    .turn-btn-message {
      font-size: 12px;
      color: #6e7681;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 2px;
    }
    .turn-btn:hover {
      background: #30363d;
      border-color: #58a6ff;
    }
    .turn-btn:hover .turn-btn-id {
      color: #58a6ff;
    }
    .turn-btn.active {
      background: #1f6feb;
      border-color: #1f6feb;
      color: #fff;
    }
    .turn-btn.active .turn-btn-id,
    .turn-btn.active .turn-btn-message {
      color: #fff;
    }
    
    /* Event filters */
    .event-filters {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-btn {
      padding: 6px 10px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #c9d1d9;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      text-align: left;
      width: 100%;
    }
    .filter-btn:not(:disabled):hover { 
      background: #30363d; 
    }
    .filter-btn.active {
      background: #1f6feb;
      border-color: #1f6feb;
      color: #fff;
    }
    .filter-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: #161b22;
      color: #6e7681;
    }
    
    /* Content */
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    
    .scroll-indicator {
      padding: 8px 12px;
      background: #0d1117;
      border-bottom: 1px solid #30363d;
      font-size: 12px;
      color: #c9d1d9;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .content-toolbar-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .content-toolbar-center {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
    }
    
    .search-input {
      width: 300px;
      padding: 6px 12px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .search-input:focus {
      border-color: #58a6ff;
      background: #0d1117;
    }
    
    .search-input::placeholder {
      color: #6e7681;
    }
    
    /* Search highlight */
    .search-highlight {
      background: #ffd33d;
      color: #1f2328;
      padding: 1px 2px;
      border-radius: 2px;
      font-weight: 500;
    }
    
    /* Search result counter */
    .search-result-count {
      margin-left: 12px;
      font-size: 12px;
      color: #c9d1d9;
      padding: 4px 8px;
      background: #21262d;
      border-radius: 4px;
      white-space: nowrap;
    }
    
    .filter-dropdown {
      position: relative;
    }
    
    .filter-dropdown-toggle {
      padding: 12px 16px;
      min-height: 44px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .filter-dropdown-toggle:hover {
      border-color: #58a6ff;
      background: #0d1117;
    }
    
    .filter-count {
      background: #58a6ff;
      color: #0d1117;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 12px;
      font-weight: 600;
    }
    
    .filter-dropdown-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      min-width: 250px;
      z-index: 1000;
    }
    
    .filter-dropdown-header {
      padding: 8px 12px;
      border-bottom: 1px solid #30363d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      font-weight: 600;
      color: #c9d1d9;
    }
    
    .clear-filters-btn {
      background: none;
      border: none;
      color: #58a6ff;
      cursor: pointer;
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    .clear-filters-btn:hover {
      background: rgba(88, 166, 255, 0.1);
    }
    
    .filter-options {
      max-height: 300px;
      overflow-y: auto;
      padding: 4px 0;
    }
    
    .filter-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 13px;
    }
    
    .filter-option:hover {
      background: rgba(88, 166, 255, 0.1);
    }
    
    .filter-option input[type="checkbox"] {
      cursor: pointer;
      accent-color: #58a6ff;
    }
    
    .filter-option-label {
      flex: 1;
      color: #c9d1d9;
    }
    
    .filter-option-count {
      color: #7d8590;
      font-size: 12px;
    }
    
    .content-toolbar-right {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
    }
    
    /* Turn navigation in toolbar */
    .turn-dropdown {
      padding: 6px 12px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      cursor: pointer;
      min-width: 260px;
      transition: border-color 0.2s;
    }

    .turn-dropdown:hover {
      border-color: #58a6ff;
    }

    .turn-dropdown:focus {
      outline: none;
      border-color: #58a6ff;
    }

    .turn-dropdown optgroup {
      font-weight: 600;
      font-style: normal;
      color: #e6edf3;
      background: #21262d;
      padding: 4px 0;
    }

    .turn-dropdown option {
      font-weight: 400;
      color: #c9d1d9;
      background: #161b22;
      padding: 4px 8px;
    }
    
    /* Virtual Scroller */
    .vue-recycle-scroller {
      flex: 1;
    }
    .vue-recycle-scroller__item-wrapper {
      overflow: visible !important;
    }
    
    /* Events */
    .event {
      background: #161b22;
      border-left: 3px solid #30363d;
      padding: 6px 12px 6px 12px;
      margin: 0;
      border-radius: 0;
      font-size: 13px;
    }
    .event:nth-child(even) {
      background: #1c2128;
    }
    /* Separator inside event (properly measured by virtual scroller) */
    .event-separator {
      height: 1px;
      background: #0d1117;
      margin: 12px 0 0 0;
    }
    .event.turn-boundary {
      background: #1c2128;
      border-left: 4px solid #8250df;
      padding: 8px 12px;
      box-shadow: 0 0 8px rgba(130, 80, 223, 0.15);
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .event-badge {
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      min-width: 90px;
      text-align: center;
      display: inline-block;
      line-height: 1.4;
    }
    .badge-user { background: #1f6feb; color: #fff; }
    .badge-assistant { background: #238636; color: #fff; }
    .badge-reasoning { background: #a371f7; color: #fff; }
    .badge-turn { background: #8250df; color: #fff; }
    .badge-tool { background: #9e6a03; color: #fff; }
    .badge-subagent { background: #8957e5; color: #fff; }
    .badge-skill { background: #bf3989; color: #fff; }
    .badge-session { background: #6e7681; color: #fff; }
    .badge-truncation { background: #e5534b; color: #fff; }
    .badge-compaction { background: #c2442d; color: #fff; }
    .badge-error { background: #da3633; color: #fff; }
    .badge-warning { background: #d29922; color: #000; }
    .badge-info { background: #58a6ff; color: #fff; }
    
    .event-content {
      color: #c9d1d9;
      text-align: left;
      font-size: 13px;
    }
    
    /* Model change styling */
    .model-change-content {
      margin-top: 6px;
    }
    
    .model-change-text {
      font-size: 13px;
      color: #e6edf3;
    }
    
    .model-name {
      color: #58a6ff;
      font-weight: 600;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 13px;
    }
    
    .model-arrow {
      color: #7d8590;
      margin: 0 8px;
    }
    
    /* Markdown styling */
    .event-content code {
      background: #161b22;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      color: #f0883e;
    }
    .event-content pre {
      background: #161b22;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 8px 0;
      border: 1px solid #30363d;
      font-size: 13px;
    }
    .event-content pre code {
      background: none;
      padding: 0;
      color: #e6edf3;
    }
    .event-content a {
      color: #58a6ff;
      text-decoration: none;
    }
    .event-content a:hover {
      text-decoration: underline;
    }
    .event-content ul, .event-content ol {
      padding-left: 24px;
      margin: 8px 0;
    }
    .event-content li {
      margin: 4px 0;
    }
    .event-content blockquote {
      border-left: 3px solid #30363d;
      padding-left: 12px;
      margin: 8px 0;
      color: #c9d1d9;
    }
    .event-content strong {
      color: #e6edf3;
      font-weight: 600;
    }
    .event-content em {
      color: #e6edf3;
      font-style: italic;
    }
    .event-content h1, .event-content h2, .event-content h3, 
    .event-content h4, .event-content h5, .event-content h6 {
      color: #e6edf3;
      margin: 12px 0 6px 0;
      font-weight: 600;
    }
    .event-content h1 { font-size: 16px; }
    .event-content h2 { font-size: 15px; }
    .event-content h3 { font-size: 14px; }
    .event-content h4 { font-size: 13px; }
    .event-content p {
      margin: 6px 0;
    }
    
    /* Markdown table styling */
    .event-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 12px 0;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
    }
    .event-content th {
      background: #21262d;
      padding: 8px 12px;
      text-align: left;
      font-weight: 600;
      color: #e6edf3;
      border-bottom: 1px solid #30363d;
    }
    .event-content td {
      padding: 8px 12px;
      border-bottom: 1px solid #30363d;
    }
    .event-content tr:last-child td {
      border-bottom: none;
    }
    .event-content tbody tr:hover {
      background: rgba(110, 118, 129, 0.1);
    }
    
    .event-timestamp {
      font-size: 12px;
      color: #c9d1d9;
    }
    
    /* Tool calls */
    .tool-list {
      margin-top: 6px;
      padding-left: 8px;
      border-left: 2px solid rgba(110, 118, 129, 0.3);
    }
    .tool-item {
      padding: 2px 0;
    }
    .tool-header-line {
      color: #c9d1d9;
      font-size: 13px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      cursor: pointer;
      user-select: none;
      line-height: 1;
      display: flex;
      align-items: center;
      gap: 0;
      padding: 2px 0;
    }
    .tool-header-line:hover {
      color: #c9d1d9;
    }
    .tool-connector {
      color: #6e7681;
      margin-right: 0;
      flex-shrink: 0;
      line-height: 1;
    }
    .tool-expand-icon {
      color: #6e7681;
      margin: 0 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 12px;
      height: 12px;
      flex-shrink: 0;
      line-height: 1;
      transform: translateY(-1px);
    }
    .tool-name {
      color: #f0883e;
      flex-shrink: 0;
      margin-right: 4px;
    }
    .tool-status-success {
      color: #238636;
    }
    .tool-status-error {
      color: #da3633;
    }
    .tool-status-running {
      color: #d29922;
    }
    .tool-detail {
      margin-top: 4px;
      padding: 8px;
      background: rgba(110, 118, 129, 0.05);
      border-radius: 3px;
      border: 1px solid #30363d;
      font-size: 12px;
    }
    .tool-detail-section {
      margin-bottom: 6px;
    }
    .tool-detail-section:last-child {
      margin-bottom: 0;
    }
    .tool-detail-title {
      color: #7d8590;
      margin-bottom: 2px;
      font-weight: 600;
      font-size: 12px;
    }
    .tool-detail-content pre {
      margin: 0;
      padding: 4px 6px;
      background: #0d1117;
      border-radius: 3px;
      overflow-x: auto;
      max-height: 200px;
      font-size: 12px;
      line-height: 1.3;
      color: #e6edf3;
    }
    
    /* Turn divider - Design 3: Slack Style (居中对称) */
    .turn-divider {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 12px;
      margin: 0;
      background: transparent;
    }
    .turn-divider::before,
    .turn-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #30363d;
    }
    .turn-divider-text {
      color: #7d8590;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      white-space: nowrap;
      padding: 2px 8px;
      background: #0d1117;
      border-radius: 10px;
      border: 1px solid #21262d;
      margin: 0;
    }
    .turn-divider-line-left,
    .turn-divider-line-right {
      display: none;
    }
    
    /* Divider separator (for turn and subagent dividers) - HIDDEN */
    .divider-separator {
      display: none;
    }
    
    /* Subagent divider - Slack Style (unified color) */
    .subagent-divider {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 12px;
      margin: 0;
      background: transparent;
    }
    .subagent-divider::before,
    .subagent-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: #58a6ff;
    }
    .subagent-divider-text {
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
      letter-spacing: 0.8px;
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid #58a6ff;
      margin: 0;
      text-transform: uppercase;
      color: #58a6ff;
      background: rgba(88, 166, 255, 0.1);
    }
    .subagent-divider-line-left,
    .subagent-divider-line-right {
      display: none;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  
  <!-- Session data -->
  <script>
    window.sessionData = {
      sessionId: '<%= sessionId %>',
      metadata: <%- JSON.stringify(metadata).replace(/</g, '\\u003c').replace(/>/g, '\\u003e').replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029') %>,
      events: [] // Will be loaded asynchronously
    };
  </script>
  
  <!-- Vue App -->
  <script>
    const { createApp, ref, computed, onMounted, onBeforeUnmount, reactive, watch } = Vue;
    const { DynamicScroller, DynamicScrollerItem } = window.VueVirtualScroller;
    
    const app = createApp({
      components: {
        DynamicScroller,
        DynamicScrollerItem
      },
      
      setup() {
        const sessionId = ref(window.sessionData.sessionId);
        const metadata = ref(window.sessionData.metadata);
        const exporting = ref(false);
        
        // Load sidebar state from localStorage
        const sidebarCollapsed = ref(
          localStorage.getItem('sidebarCollapsed') === 'true'
        );
        
        // Persist sidebar state to localStorage
        watch(sidebarCollapsed, (newValue) => {
          localStorage.setItem('sidebarCollapsed', newValue.toString());
        });
        
        const expandedTools = ref({});
        const expandedContent = ref({});
        const currentFilter = ref('all');
        const searchText = ref('');
        const debouncedSearchText = ref('');
        const currentTurnIndex = ref(0);  // Current selected turn
        const scrollerRef = ref(null);
        const visibleRange = ref({ start: 0, end: 0 });
        
        // Debounce search input
        let searchTimeout = null;
        watch(searchText, (newValue) => {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            debouncedSearchText.value = newValue;
          }, 300);
        });
        
        // Async loading state
        const loadedEvents = ref([]);
        const eventsLoading = ref(true);
        const eventsError = ref(null);
        
        // Flatten and sort events
        const flatEvents = computed(() => {
          const events = loadedEvents.value
            .filter(e => 
              e.type !== 'assistant.turn_end' && 
              e.type !== 'assistant.turn_complete'
            )
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
            .map((e, index) => ({ 
              ...e, 
              virtualIndex: index,
              stableId: e.id || `${e.timestamp}-${e.type}-${index}`  // Stable ID for toggle state
            }));
          return events;
        });
        
        // Helper: check if event matches search
        const matchesSearch = (e) => {
          if (!debouncedSearchText.value.trim()) return true;
          
          const search = debouncedSearchText.value.toLowerCase();
          // Only search in event.data fields, not type
          const content = [
            e.data?.message,
            e.data?.text,
            e.data?.content,
            e.data?.reason,
            e.data?.errorType,
            e.data?.previousModel,
            e.data?.newModel
          ].filter(Boolean).join(' ').toLowerCase();
          
          return content.includes(search);
        };
        
        // Events after search (before type filter) - used for filter counts
        const searchFilteredEvents = computed(() => {
          const excludeToolCalls = (e) => {
            const eventType = e.type || '';
            return eventType !== 'tool.execution_start' && eventType !== 'tool.execution_complete';
          };
          
          let events = flatEvents.value.filter(excludeToolCalls);
          
          // Apply search only (use debouncedSearchText for consistency)
          if (debouncedSearchText.value.trim()) {
            events = events.filter(matchesSearch);
          }
          
          return events;
        });
        
        // Final filtered events (search + type filter)
        const filteredEvents = computed(() => {
          let events = searchFilteredEvents.value;
          
          // Apply type filter
          if (currentFilter.value !== 'all') {
            events = events.filter(e => e.type === currentFilter.value);
          }
          
          // Divider types (no separator before these)
          const dividerTypes = ['assistant.turn_start', 'subagent.started', 'subagent.completed', 'subagent.failed'];
          
          // Mark events that shouldn't have separator
          const totalCount = events.length;
          return events.map((e, index) => {
            const nextItem = events[index + 1];
            const isLast = index === totalCount - 1;
            const nextIsDivider = nextItem && dividerTypes.includes(nextItem.type);
            
            return {
              ...e,
              filteredIndex: index,
              filteredTotal: totalCount,
              isLastEvent: isLast || nextIsDivider  // Hide separator if last OR next is divider
            };
          });
        });
        
        // Event type counts (based on search results)
        const eventCounts = computed(() => {
          const counts = {};
          searchFilteredEvents.value.forEach(e => {
            if (e.type) {
              counts[e.type] = (counts[e.type] || 0) + 1;
            }
          });
          return counts;
        });
        
        // Search result count for display
        const searchResultCount = computed(() => {
          if (!debouncedSearchText.value.trim()) return null;
          const count = searchFilteredEvents.value.length;
          return count > 0 ? `${count} result${count !== 1 ? 's' : ''}` : 'No matches';
        });
        
        // Track expansion state changes for size-dependencies
        const expansionCount = computed(() => {
          const toolsExpanded = Object.keys(expandedTools.value).filter(k => expandedTools.value[k]).length;
          const contentExpanded = Object.keys(expandedContent.value).filter(k => expandedContent.value[k]).length;
          return toolsExpanded + contentExpanded;
        });
        
        // Available filters (with counts based on search results)
        const filters = computed(() => {
          const totalEvents = searchFilteredEvents.value.length;
          
          // Start with "All" filter
          const result = [{ type: 'all', label: `All (${totalEvents})`, count: totalEvents }];
          
          // Dynamically extract all event types from actual events
          const typeCounts = {};
          searchFilteredEvents.value.forEach(e => {
            if (e.type) {
              typeCounts[e.type] = (typeCounts[e.type] || 0) + 1;
            }
          });
          
          // Convert to array and sort by count (descending)
          const sortedTypes = Object.entries(typeCounts)
            .sort((a, b) => b[1] - a[1])  // Sort by count descending
            .map(([type, count]) => ({
              type,
              label: `${type} (${count})`,
              count,
              disabled: false
            }));
          
          return [...result, ...sortedTypes];
        });
        
        // Turns
        const turns = computed(() => {
          const turnStarts = flatEvents.value.filter(e => e.type === 'assistant.turn_start');
          const allUserMessages = flatEvents.value.filter(e => e.type === 'user.message');

          return turnStarts.map((turn, idx) => {
            // Use idx as the display turn number (sequential, no duplicates)
            const turnId = idx;
            const startTime = new Date(turn.timestamp).getTime();

            // Find turn end
            let endTime;
            const nextTurnIndex = turnStarts.indexOf(turn) + 1;
            if (nextTurnIndex < turnStarts.length) {
              endTime = new Date(turnStarts[nextTurnIndex].timestamp).getTime();
            } else {
              endTime = Date.now();
            }

            // Calculate duration
            const durationMs = endTime - startTime;
            const totalSeconds = Math.floor(durationMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const durationText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;

            // Find user message before this turn
            const userMessage = flatEvents.value
              .slice(0, flatEvents.value.indexOf(turn))
              .reverse()
              .find(e => e.type === 'user.message');

            // Calculate UserReq number (1-indexed)
            const userReqNumber = userMessage
              ? allUserMessages.indexOf(userMessage) + 1
              : 0;

            return {
              id: turnId,
              index: turn.virtualIndex,
              originalTurnId: turn.data?.turnId,  // Keep original for reference
              timestamp: turn.timestamp,
              duration: durationText,
              message: userMessage?.data?.message || '',
              userReqNumber: userReqNumber
            };
          });
        });

        // Group turns by UserReq for optgroup navigation
        const userReqs = computed(() => {
          const groups = [];
          const reqMap = new Map();

          turns.value.forEach(turn => {
            const reqNum = turn.userReqNumber || 0;
            if (!reqMap.has(reqNum)) {
              const group = {
                reqNumber: reqNum,
                message: turn.message,
                turns: []
              };
              reqMap.set(reqNum, group);
              groups.push(group);
            }
            reqMap.get(reqNum).turns.push(turn);
          });

          return groups;
        });

        // Truncate text helper for optgroup labels
        const truncateText = (text, maxLen) => {
          if (!text) return '';
          if (text.length <= maxLen) return text;
          return text.substring(0, maxLen) + '…';
        };
        
        // Tool call map
        const toolCallMap = computed(() => {
          const map = new Map();
          const toolGroups = new Map();
          
          flatEvents.value.forEach(event => {
            if (event.type === 'tool.execution_start') {
              const toolId = event.data?.toolCallId;
              if (toolId) {
                if (!toolGroups.has(toolId)) {
                  toolGroups.set(toolId, { tool: event.data.tool, start: event });
                }
              }
            } else if (event.type === 'tool.execution_complete') {
              const toolId = event.data?.toolCallId;
              if (toolId && toolGroups.has(toolId)) {
                toolGroups.get(toolId).complete = event;
              }
            }
          });
          
          flatEvents.value.forEach(event => {
            if (event.type === 'assistant.message') {
              const groups = [];
              toolGroups.forEach((group, toolId) => {
                if (group.start?.parentId === event.id) {
                  groups.push(group);
                }
              });
              if (groups.length > 0) {
                map.set(event.id || event.virtualIndex, groups);
              }
            }
          });
          
          return map;
        });
        
        // Methods
        const formatTime = (timestamp) => {
          if (!timestamp) return '';
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const seconds = String(date.getSeconds()).padStart(2, '0');
          return `${hours}:${minutes}:${seconds}`;
        };
        
        const renderMarkdown = (text) => {
          if (!text) return '';
          try {
            // 处理转义序列：将 \r\n、\n、\t 等转换为实际字符
            let processedText = text
              .replace(/\\r\\n/g, '\n')  // \r\n → 换行
              .replace(/\\n/g, '\n')      // \n → 换行
              .replace(/\\t/g, '\t')      // \t → 制表符
              .replace(/\\"/g, '"')       // \" → 引号
              .replace(/\\\\/g, '\\');    // \\ → 反斜杠
            
            // Parse YAML frontmatter
            const frontmatterMatch = processedText.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
            if (frontmatterMatch) {
              const frontmatter = frontmatterMatch[1];
              const content = frontmatterMatch[2];
              
              // Parse frontmatter into key-value pairs
              const pairs = frontmatter.split('\n').filter(line => line.trim() && line.includes(':')).map(line => {
                const colonIndex = line.indexOf(':');
                const key = line.substring(0, colonIndex).trim();
                const value = line.substring(colonIndex + 1).trim();
                return { key, value };
              });
              
              // Render frontmatter as table
              let tableHTML = '<table style="margin-bottom: 16px; border-collapse: collapse;"><tbody>';
              pairs.forEach(pair => {
                tableHTML += `<tr><td style="padding: 4px 12px; border: 1px solid #30363d; font-weight: 600; color: #7d8590;">${pair.key}</td><td style="padding: 4px 12px; border: 1px solid #30363d;">${pair.value}</td></tr>`;
              });
              tableHTML += '</tbody></table>';
              
              // Render remaining content
              return tableHTML + marked.parse(content);
            }
            
            return marked.parse(processedText);
          } catch (e) {
            return text;
          }
        };
        
        const toggleTool = (toolId) => {
          const newState = { ...expandedTools.value };
          if (newState[toolId]) {
            delete newState[toolId];
          } else {
            newState[toolId] = true;
          }
          expandedTools.value = newState;
        };
        
        const highlightSearchText = (html, searchTerm) => {
          if (!searchTerm || !searchTerm.trim() || !html) return html;
          
          const term = searchTerm.trim();
          // Escape HTML in search term to prevent XSS
          const escapedTerm = escapeHtml(term)
            .replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // Also escape regex special chars
          
          // Create a temporary element to parse HTML
          const temp = document.createElement('div');
          temp.innerHTML = html;
          
          // Function to highlight text in text nodes
          const highlightTextNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent;
              const regex = new RegExp(`(${escapedTerm})`, 'gi');
              if (regex.test(text)) {
                const highlighted = text.replace(regex, '<mark class="search-highlight">$1</mark>');
                const span = document.createElement('span');
                span.innerHTML = highlighted;
                node.parentNode.replaceChild(span, node);
              }
            } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName !== 'SCRIPT' && node.tagName !== 'STYLE') {
              Array.from(node.childNodes).forEach(highlightTextNode);
            }
          };
          
          Array.from(temp.childNodes).forEach(highlightTextNode);
          return temp.innerHTML;
        };
        
        const toggleContent = (contentId) => {
          // Create new object to trigger Vue reactivity
          const newState = { ...expandedContent.value };
          if (newState[contentId]) {
            delete newState[contentId];
          } else {
            newState[contentId] = true;
          }
          expandedContent.value = newState;
        };
        
        const isContentTooLong = (text) => {
          if (!text) return false;
          const lineCount = text.split('\n').length;
          return lineCount > 20 || text.length > 2000;
        };
        
        const truncateContent = (text) => {
          const lines = text.split('\n');
          if (lines.length <= 20) return text;
          return lines.slice(0, 20).join('\n') + '\n\n...';
        };
        
        const getBadgeInfo = (type) => {
          // Special case for specific event types
          if (type === 'session.model_change') {
            return { label: 'MODEL CHANGE', class: 'badge-session' };
          }
          if (type === 'session.truncation') {
            return { label: 'TRUNCATION', class: 'badge-truncation' };
          }
          if (type === 'session.compaction_start' || type === 'session.compaction_complete') {
            return { label: 'COMPACTION', class: 'badge-compaction' };
          }
          
          const parts = (type || '').split('.');
          const category = parts[0] || 'unknown';
          
          const badges = {
            user: { label: 'USER', class: 'badge-user' },
            assistant: { label: 'ASSISTANT', class: 'badge-assistant' },
            reasoning: { label: 'REASONING', class: 'badge-reasoning' },
            turn: { label: 'TURN', class: 'badge-turn' },
            tool: { label: 'TOOL', class: 'badge-tool' },
            subagent: { label: 'SUBAGENT', class: 'badge-subagent' },
            skill: { label: 'SKILL', class: 'badge-skill' },
            session: { label: 'SESSION', class: 'badge-session' },
            error: { label: 'ERROR', class: 'badge-error' },
            abort: { label: 'ABORT', class: 'badge-error' }
          };
          
          return badges[category] || { label: category.toUpperCase(), class: 'badge-info' };
        };
        
        const getToolStatus = (group) => {
          if (!group.complete) {
            return { icon: '⏳', color: 'tool-status-running', text: '' };
          }
          
          const completeData = group.complete.data || {};
          if (completeData.error || completeData.isError) {
            return { icon: '❌', color: 'tool-status-error', text: '' };
          }
          
          return { icon: '✓', color: 'tool-status-success', text: '' };
        };
        
        const getToolErrorMessage = (group) => {
          if (!group.complete?.data?.error) return '';
          
          const error = group.complete.data.error;
          
          // If error is an object with message property
          if (typeof error === 'object' && error.message) {
            return error.message;
          }
          
          // If error is a string, try to parse as JSON
          if (typeof error === 'string') {
            try {
              const parsed = JSON.parse(error);
              if (parsed.message) return parsed.message;
            } catch (e) {
              // Not JSON, return as-is
            }
            return error;
          }
          
          // Fallback to stringified error
          return String(error);
        };
        
        const getToolDuration = (group) => {
          if (!group.complete) return '';
          
          const startTime = new Date(group.start.timestamp).getTime();
          const endTime = new Date(group.complete.timestamp).getTime();
          const durationMs = endTime - startTime;
          
          if (durationMs >= 100) {
            return `${(durationMs / 1000).toFixed(1)}s`;
          }
          return '';
        };
        
        const getToolCommand = (group) => {
          if (!group.start) return '';
          const args = group.start.data?.arguments || {};
          const toolName = group.start.data?.toolName || group.tool || '';
          
          let command = '';
          if (toolName === 'bash' || toolName === 'exec') {
            command = args.command || args.description || '';
          } else if (toolName === 'ask_user') {
            command = args.question || args.message || '';
          } else if (toolName === 'read' || toolName === 'write' || toolName === 'edit') {
            command = args.file_path || args.path || '';
          } else if (toolName === 'view') {
            command = args.path || args.file || '';
          } else if (toolName === 'create') {
            command = args.path || args.name || '';
          } else if (toolName === 'report_intent') {
            command = args.intent || args.message || '';
          } else if (toolName === 'web_search') {
            command = args.query || '';
          } else if (toolName === 'web_fetch') {
            command = args.url || '';
          } else if (toolName === 'browser') {
            const action = args.action || '';
            const url = args.targetUrl || args.url || '';
            command = url ? `${action} ${url}` : action;
          } else {
            command = args.description || args.command || args.message || 
                      args.path || args.file_path || args.query || '';
          }
          
          if (command && command.length > 100) {
            command = command.substring(0, 100) + '...';
          }
          
          return command;
        };
        
        const hasTools = (event) => {
          return event.type === 'assistant.message' && toolCallMap.value.has(event.id || event.virtualIndex);
        };
        
        const getToolGroups = (event) => {
          return toolCallMap.value.get(event.id || event.virtualIndex) || [];
        };
        
        const setFilter = (type) => {
          currentFilter.value = type;
        };
        
        const scrollToTurn = (turn) => {
          // Clear search and filter when jumping to a turn
          searchText.value = '';
          currentFilter.value = 'all';

          currentTurnIndex.value = turn.id;

          // Wait for DOM to update and virtual scroller to re-calculate
          Vue.nextTick(() => {
            if (scrollerRef.value) {
              // Use turn.index (virtualIndex) to find the exact turn_start event
              const targetIndex = filteredEvents.value.findIndex(e =>
                e.virtualIndex === turn.index
              );

              if (targetIndex >= 0) {
                // DynamicScroller with variable heights needs multiple scroll passes
                // to converge on the correct position as it measures real item sizes
                const doScroll = (attempts) => {
                  if (attempts <= 0 || !scrollerRef.value) return;
                  scrollerRef.value.scrollToItem(targetIndex);
                  setTimeout(() => doScroll(attempts - 1), 100);
                };
                setTimeout(() => doScroll(3), 50);
              }
            }
          });
        };
        
        const jumpToTurn = (turnId) => {
          const turn = turns.value.find(t => t.id === turnId);
          if (turn) {
            scrollToTurn(turn);
          }
        };
        
        const getTurnNumber = (virtualIndex) => {
          // Find the turn with matching virtualIndex
          const turn = turns.value.find(t => t.index === virtualIndex);
          if (!turn) return '?';

          const turnLabel = turn.originalTurnId != null ? turn.originalTurnId : turn.id;
          // Format: "UserReq N - Turn M" or just "Turn M" if no UserReq
          if (turn.userReqNumber > 0) {
            return `${turn.userReqNumber} - Turn ${turnLabel}`;
          }
          return `Turn ${turnLabel}`;
        };
        const escapeHtml = (text) => {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        };
        
        const formatDateTime = (timestamp) => {
          if (!timestamp) return 'N/A';
          return new Date(timestamp).toLocaleString();
        };
        
        const exportSession = async () => {
          exporting.value = true;
          try {
            const response = await fetch(`/session/${sessionId.value}/export`);
            if (!response.ok) {
              throw new Error('Share failed');
            }
            
            // Download the file
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `session-${sessionId.value}.zip`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
          } catch (err) {
            console.error('Share session error:', err);
            alert('Failed to share session: ' + err.message);
          } finally {
            exporting.value = false;
          }
        };
        

        // Lifecycle
        onMounted(async () => {
          // Load events asynchronously
          try {
            const response = await fetch(`/api/sessions/${sessionId.value}/events`);
            if (!response.ok) {
              throw new Error(`Failed to load events: ${response.statusText}`);
            }
            loadedEvents.value = await response.json();
          } catch (error) {
            console.error('Error loading events:', error);
            eventsError.value = error.message;
          } finally {
            eventsLoading.value = false;
          }
          
          window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
              e.preventDefault();
              sidebarCollapsed.value = !sidebarCollapsed.value;
            }
          });
          
          if (window.marked) {
            marked.setOptions({
              breaks: true,
              gfm: true
            });
          }
          
          // 监听滚动事件来更新 visibleRange
          const updateVisibleRange = () => {
            if (!scrollerRef.value) return;
            
            // 尝试多种方式访问 scroller 元素
            let scroller = null;
            if (scrollerRef.value.$el && typeof scrollerRef.value.$el.querySelector === 'function') {
              scroller = scrollerRef.value.$el.querySelector('.vue-recycle-scroller');
            } else if (scrollerRef.value.querySelector && typeof scrollerRef.value.querySelector === 'function') {
              scroller = scrollerRef.value.querySelector('.vue-recycle-scroller');
            }
            
            if (!scroller) {
              // 如果还找不到，直接查询 DOM
              scroller = document.querySelector('.vue-recycle-scroller');
            }
            
            if (scroller) {
              const scrollTop = scroller.scrollTop;
              const clientHeight = scroller.clientHeight;
              
              // 估算可见范围
              const avgItemHeight = 80;
              const startIndex = Math.floor(scrollTop / avgItemHeight);
              const visibleCount = Math.ceil(clientHeight / avgItemHeight);
              const endIndex = Math.min(startIndex + visibleCount, filteredEvents.value.length);
              
              const startPos = Math.max(1, startIndex + 1);
              const endPos = Math.max(1, endIndex);
              
              visibleRange.value = {
                start: Math.min(startPos, endPos), // Ensure start <= end
                end: endPos
              };
            }
          };
          
          // 初始更新和添加滚动监听
          let scrollCleanup = null;
          setTimeout(() => {
            updateVisibleRange();
            
            const scroller = document.querySelector('.vue-recycle-scroller');
            if (scroller) {
              scroller.addEventListener('scroll', updateVisibleRange);
              // Store cleanup function
              scrollCleanup = () => {
                scroller.removeEventListener('scroll', updateVisibleRange);
              };
            }
          }, 500);
          
          // Cleanup on unmount
          onBeforeUnmount(() => {
            if (scrollCleanup) {
              scrollCleanup();
            }
          });
        });
        
        return {
          sessionId,
          metadata,
          exporting,
          sidebarCollapsed,
          expandedTools,
          expandedContent,
          expansionCount,
          currentFilter,
          searchText,
          currentTurnIndex,
          scrollerRef,
          visibleRange,
          loadedEvents,
          eventsLoading,
          eventsError,
          flatEvents,
          filteredEvents,
          eventCounts,
          filters,
          turns,
          userReqs,
          truncateText,
          toolCallMap,
          formatTime,
          formatDateTime,
          renderMarkdown,
          highlightSearchText,
          toggleTool,
          toggleContent,
          isContentTooLong,
          truncateContent,
          getBadgeInfo,
          getToolStatus,
          getToolErrorMessage,
          getToolDuration,
          getToolCommand,
          hasTools,
          getToolGroups,
          setFilter,
          scrollToTurn,
          jumpToTurn,
          getTurnNumber,
          escapeHtml,
          exportSession
        };
      },
      
      template: `
        <div class="container">
          <div class="header">
            <a href="/" class="home-btn">← Back to Home</a>
            <h1>📋 Session: {{ sessionId }}</h1>
            <div style="display: flex; gap: 10px;">
              <a :href="'/session/' + sessionId + '/time-analyze'" class="time-analyze-btn">⏱ Analysis</a>
              <button @click="exportSession" class="export-btn" :disabled="exporting">
                {{ exporting ? '⏳ Sharing...' : '📤 Share Session' }}
              </button>
            </div>
          </div>
          
          <div class="main-layout">
            <div :class="['sidebar', { collapsed: sidebarCollapsed }]">
              <div class="sidebar-section">
                <div class="sidebar-section-title">Session Info</div>
                <div class="session-info">
                  <div v-if="metadata.summary" class="session-summary-block">{{ metadata.summary }}</div>
                  <table class="session-info-table">
                    <tbody>
                      <tr v-if="metadata.copilotVersion">
                        <td>CLI Version</td>
                        <td>{{ metadata.copilotVersion }}</td>
                      </tr>
                      <tr v-if="metadata.model">
                        <td>Model</td>
                        <td>{{ metadata.model }}</td>
                      </tr>
                      <tr v-if="metadata.repo">
                        <td>Repo</td>
                        <td>{{ metadata.repo }}</td>
                      </tr>
                      <tr v-if="metadata.branch">
                        <td>Branch</td>
                        <td>{{ metadata.branch }}</td>
                      </tr>
                      <tr v-if="metadata.cwd">
                        <td>CWD</td>
                        <td>{{ metadata.cwd }}</td>
                      </tr>
                      <tr v-if="metadata.created">
                        <td>Created</td>
                        <td>{{ formatDateTime(metadata.created) }}</td>
                      </tr>
                      <tr v-if="metadata.updated">
                        <td>Updated</td>
                        <td>{{ formatDateTime(metadata.updated) }}</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              
              <div class="sidebar-section">
                <div class="sidebar-section-title">Event Filters</div>
                <div class="event-filters">
                  <button
                    v-for="filter in filters"
                    :key="filter.type"
                    :class="['filter-btn', { active: currentFilter === filter.type }]"
                    :disabled="filter.disabled"
                    @click="setFilter(filter.type)"
                  >
                    {{ filter.label }}
                  </button>
                </div>
              </div>
            </div>
            
            <div class="content">
              <div class="scroll-indicator">
                <div class="content-toolbar-left">
                  <button 
                    class="sidebar-toggle"
                    @click="sidebarCollapsed = !sidebarCollapsed"
                    :title="sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'"
                  >
                    ☰
                  </button>
                  
                  <!-- Turn dropdown with optgroup -->
                  <select
                    v-if="turns.length > 0"
                    v-model="currentTurnIndex"
                    @change="jumpToTurn(currentTurnIndex)"
                    class="turn-dropdown"
                  >
                    <optgroup
                      v-for="req in userReqs"
                      :key="req.reqNumber"
                      :label="req.reqNumber > 0 ? 'UserReq ' + req.reqNumber + ': ' + truncateText(req.message, 40) : 'Setup'"
                    >
                      <option v-for="turn in req.turns" :key="turn.id" :value="turn.id">
                        Turn {{ turn.originalTurnId != null ? turn.originalTurnId : turn.id }} ({{ turn.duration }})
                      </option>
                    </optgroup>
                  </select>
                </div>
                <div class="content-toolbar-center">
                </div>
                <div class="content-toolbar-right">
                  <input 
                    v-model="searchText" 
                    type="text" 
                    placeholder="🔍 Search events..." 
                    class="search-input"
                  />
                  <span v-if="searchResultCount" class="search-result-count">
                    {{ searchResultCount }}
                  </span>
                </div>
              </div>
              
              <!-- Loading state -->
              <div v-if="eventsLoading" class="loading-message">
                <div style="text-align: center; padding: 40px; color: #c9d1d9;">
                  ⏳ Loading events...
                </div>
              </div>
              
              <!-- Error state -->
              <div v-else-if="eventsError" class="error-message">
                <div style="text-align: center; padding: 40px; color: #f85149;">
                  ❌ Error loading events: {{ eventsError }}
                </div>
              </div>
              
              <!-- Events list -->
              <DynamicScroller
                v-else
                ref="scrollerRef"
                :items="filteredEvents"
                :min-item-size="80"
                key-field="stableId"
                class="scroller"
              >
                <template #default="{ item, index, active }">
                  <DynamicScrollerItem
                    :item="item"
                    :active="active"
                    :size-dependencies="[expansionCount]"
                    :data-index="index"
                  >
                    <!-- Turn Start Divider -->
                    <div 
                      v-if="item.type === 'assistant.turn_start'"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                      class="turn-divider"
                    >
                      <div class="turn-divider-line-left"></div>
                      <span class="turn-divider-text">UserReq {{ getTurnNumber(item.virtualIndex) }} Start</span>
                      <div class="turn-divider-line-right"></div>
                      <div class="divider-separator"></div>
                    </div>
                    
                    <!-- Subagent Divider -->
                    <div 
                      v-else-if="item.type === 'subagent.started' || item.type === 'subagent.completed' || item.type === 'subagent.failed'"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                      :class="['subagent-divider', item.type.split('.')[1]]"
                    >
                      <div class="subagent-divider-line-left"></div>
                      <span class="subagent-divider-text">
                        🤖 {{ item.data?.agentDisplayName || item.data?.agentName || 'SubAgent' }}
                        {{ item.type === 'subagent.started' ? 'Start ▶' : item.type === 'subagent.completed' ? 'Complete ✓' : 'Failed ✗' }}
                      </span>
                      <div class="subagent-divider-line-right"></div>
                      <div class="divider-separator"></div>
                    </div>
                    
                    <!-- Regular Event -->
                    <div 
                      v-else
                      :class="['event']"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                    >
                      <div class="event-header">
                        <span :class="['event-badge', getBadgeInfo(item.type).class]">
                          {{ getBadgeInfo(item.type).label }}
                        </span>
                        <span class="event-timestamp">{{ formatTime(item.timestamp) }}</span>
                      </div>
                      
                      <!-- Abort event: show reason -->
                      <div v-if="item.type === 'abort' && item.data?.reason" class="event-content">
                        <strong>Reason:</strong> {{ item.data.reason }}
                      </div>
                      
                      <!-- Session start: show type and selectedModel -->
                      <div v-else-if="item.type === 'session.start'" class="event-content">
                        <div v-if="item.data?.type"><strong>Type:</strong> {{ item.data.type }}</div>
                        <div v-if="item.data?.selectedModel"><strong>Model:</strong> {{ item.data.selectedModel }}</div>
                        <div v-if="item.data?.producer"><strong>Producer:</strong> {{ item.data.producer }}</div>
                      </div>
                      
                      <!-- Session resume: show resumeTime, eventCount, context -->
                      <div v-else-if="item.type === 'session.resume'" class="event-content">
                        <div v-if="item.data?.resumeTime"><strong>Resume Time:</strong> {{ formatDateTime(item.data.resumeTime) }}</div>
                        <div v-if="item.data?.eventCount"><strong>Event Count:</strong> {{ item.data.eventCount }}</div>
                        <div v-if="item.data?.context?.branch"><strong>Branch:</strong> {{ item.data.context.branch }}</div>
                        <div v-if="item.data?.context?.repository"><strong>Repository:</strong> {{ item.data.context.repository }}</div>
                        <div v-if="item.data?.context?.cwd"><strong>Working Directory:</strong> {{ item.data.context.cwd }}</div>
                      </div>
                      
                      <!-- Session error: show errorType + message -->
                      <div v-else-if="item.type === 'session.error' && (item.data?.errorType || item.data?.message)" class="event-content">
                        <div v-if="item.data?.errorType"><strong>Error Type:</strong> {{ item.data.errorType }}</div>
                        <div v-if="item.data?.message"><strong>Message:</strong> {{ item.data.message }}</div>
                      </div>
                      
                      <!-- Model change: show previousModel → newModel -->
                      <div v-else-if="item.type === 'session.model_change'" class="event-content model-change-content">
                        <div v-if="item.data?.previousModel && item.data?.newModel" class="model-change-text">
                          <span class="model-name">{{ item.data.previousModel }}</span>
                          <span class="model-arrow">→</span>
                          <span class="model-name">{{ item.data.newModel }}</span>
                        </div>
                        <div v-else-if="item.data?.newModel" class="model-change-text">
                          Switched to <span class="model-name">{{ item.data.newModel }}</span>
                        </div>
                        <div v-else-if="item.data?.model" class="model-change-text">
                          Switched to <span class="model-name">{{ item.data.model }}</span>
                        </div>
                        <div v-else class="model-change-text">
                          Model changed
                        </div>
                      </div>

                      <!-- Session truncation: show token/message removal info -->
                      <div v-else-if="item.type === 'session.truncation'" class="event-content">
                        <div v-if="item.data?.messagesRemovedDuringTruncation"><strong>Messages removed:</strong> {{ item.data.messagesRemovedDuringTruncation }}</div>
                        <div v-if="item.data?.tokensRemovedDuringTruncation"><strong>Tokens removed:</strong> {{ item.data.tokensRemovedDuringTruncation.toLocaleString() }}</div>
                        <div v-if="item.data?.preTruncationTokensInMessages"><strong>Pre-truncation tokens:</strong> {{ item.data.preTruncationTokensInMessages.toLocaleString() }}</div>
                        <div v-if="item.data?.postTruncationMessagesLength"><strong>Post-truncation messages:</strong> {{ item.data.postTruncationMessagesLength }}</div>
                        <div v-if="item.data?.performedBy"><strong>Performed by:</strong> {{ item.data.performedBy }}</div>
                      </div>

                      <!-- Session compaction start -->
                      <div v-else-if="item.type === 'session.compaction_start'" class="event-content">
                        Context compaction started
                      </div>

                      <!-- Session compaction complete: show results -->
                      <div v-else-if="item.type === 'session.compaction_complete'" class="event-content">
                        <div v-if="item.data?.success != null"><strong>Success:</strong> {{ item.data.success ? '✓' : '✗' }}</div>
                        <div v-if="item.data?.compactionTokensUsed">
                          <strong>Tokens used:</strong>
                          input {{ item.data.compactionTokensUsed.input?.toLocaleString() || 0 }},
                          output {{ item.data.compactionTokensUsed.output?.toLocaleString() || 0 }}
                          <span v-if="item.data.compactionTokensUsed.cachedInput">, cached {{ item.data.compactionTokensUsed.cachedInput.toLocaleString() }}</span>
                        </div>
                        <div v-if="item.data?.preCompactionMessagesLength"><strong>Pre-compaction messages:</strong> {{ item.data.preCompactionMessagesLength }}</div>
                        <div v-if="item.data?.preCompactionTokens"><strong>Pre-compaction tokens:</strong> {{ item.data.preCompactionTokens.toLocaleString() }}</div>
                        <div v-if="item.data?.summaryContent" style="margin-top: 8px;">
                          <button
                            @click="toggleContent('compaction-' + item.stableId)"
                            style="background: none; border: 1px solid #30363d; color: #58a6ff; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 13px;"
                          >
                            {{ expandedContent['compaction-' + item.stableId] ? 'Hide summary ▲' : 'Show summary ▼' }}
                          </button>
                          <div v-if="expandedContent['compaction-' + item.stableId]" class="event-content" style="margin-top: 8px;" v-html="renderMarkdown(item.data.summaryContent)"></div>
                        </div>
                      </div>

                      <!-- Regular content -->
                      <div v-else-if="item.data?.message || item.data?.text || item.data?.content || item.data?.transformedContent">
                        <div
                          class="event-content"
                          v-html="highlightSearchText(
                            renderMarkdown(
                              (expandedContent[item.stableId] || !isContentTooLong(item.data?.message || item.data?.text || item.data?.content || item.data?.transformedContent))
                                ? (item.data?.message || item.data?.text || item.data?.content || item.data?.transformedContent)
                                : truncateContent(item.data?.message || item.data?.text || item.data?.content || item.data?.transformedContent)
                            ),
                            searchText
                          )"
                        ></div>
                        <div
                          v-if="isContentTooLong(item.data?.message || item.data?.text || item.data?.content || item.data?.transformedContent)"
                          style="margin-top: 8px;"
                        >
                          <button
                            @click="toggleContent(item.stableId)"
                            :data-content-id="item.stableId"
                            style="background: none; border: 1px solid #30363d; color: #58a6ff; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 13px;"
                          >
                            {{ expandedContent[item.stableId] ? 'Show less ▲' : 'Show more ▼' }}
                          </button>
                        </div>
                      </div>
                      
                      <div v-if="hasTools(item)" class="tool-list">
                        <div
                          v-for="(group, idx) in getToolGroups(item)"
                          :key="idx"
                          class="tool-item"
                        >
                          <div 
                            class="tool-header-line"
                            @click="toggleTool(item.stableId + '-' + idx)"
                          >
                            <span class="tool-connector">{{ idx === getToolGroups(item).length - 1 ? '└─' : '├─' }}</span>
                            <span class="tool-expand-icon">{{ expandedTools[item.stableId + '-' + idx] ? '▼' : '▶' }}</span>
                            <span class="tool-name">🔧&nbsp;{{ group.start?.data?.toolName || group.tool || 'Tool' }}</span>
                            <span :class="getToolStatus(group).color" style="margin-left: 4px;">({{ getToolStatus(group).icon }}{{ getToolDuration(group) ? ' ' + getToolDuration(group) : '' }})</span>
                            <span v-if="getToolCommand(group)" style="color: #7d8590; margin-left: 8px;">{{ getToolCommand(group) }}</span>
                            <span v-if="getToolErrorMessage(group)" style="color: #ff7b72; margin-left: 8px;">{{ getToolErrorMessage(group).length > 80 ? getToolErrorMessage(group).substring(0, 80) + '...' : getToolErrorMessage(group) }}</span>
                          </div>
                          
                          <div v-if="expandedTools[item.stableId + '-' + idx]" class="tool-detail">
                            <div v-if="group.start?.data?.arguments" class="tool-detail-section">
                              <div class="tool-detail-title">Arguments:</div>
                              <div class="tool-detail-content">
                                <pre>{{ JSON.stringify(group.start.data.arguments, null, 2) }}</pre>
                              </div>
                            </div>
                            <div v-if="group.complete?.data?.result" class="tool-detail-section">
                              <div class="tool-detail-title">Result:</div>
                              <div class="tool-detail-content">
                                <pre>{{ JSON.stringify(group.complete.data.result, null, 2) }}</pre>
                              </div>
                            </div>
                            <div v-if="getToolErrorMessage(group)" class="tool-detail-section">
                              <div class="tool-detail-title">Error:</div>
                              <div class="tool-detail-content" style="color: #ff7b72;">
                                {{ getToolErrorMessage(group) }}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <!-- Separator (inside event for proper height calculation) -->
                      <div v-if="!item.isLastEvent" class="event-separator"></div>
                    </div>
                  </DynamicScrollerItem>
                </template>
              </DynamicScroller>
            </div>
          </div>
          
        </div>
      `
    });
    
    app.mount('#app');
  </script>
</body>
</html>
