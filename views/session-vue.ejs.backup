<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session <%= sessionId %> - Vue Virtual Scroller</title>
  
  <!-- Vue 3 -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  
  <!-- vue-virtual-scroller -->
  <link rel="stylesheet" href="https://unpkg.com/vue-virtual-scroller@2.0.0-beta.8/dist/vue-virtual-scroller.css">
  <script src="https://unpkg.com/vue-virtual-scroller@2.0.0-beta.8/dist/vue-virtual-scroller.min.js"></script>
  
  <!-- Markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      line-height: 1.5;
      overflow: hidden;
    }
    .container { 
      max-width: 100%; 
      height: 100vh; 
      display: flex;
      flex-direction: column;
      padding: 0;
    }
    
    /* Header */
    .header {
      padding: 16px 20px;
      border-bottom: 1px solid #30363d;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .home-btn {
      padding: 6px 12px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      text-decoration: none;
      font-size: 14px;
      transition: all 0.2s;
    }
    .home-btn:hover {
      background: #30363d;
      border-color: #58a6ff;
    }
    h1 { 
      color: #58a6ff; 
      font-size: 20px; 
      margin: 0;
      flex: 1;
    }
    
    /* Main layout */
    .main-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    
    /* Sidebar */
    .sidebar {
      width: 320px;
      flex-shrink: 0;
      background: #161b22;
      border-right: 1px solid #30363d;
      overflow-y: auto;
      padding: 16px;
      transition: all 0.3s ease;
      position: relative;
    }
    .sidebar.collapsed {
      width: 0;
      padding: 0;
      border-right: none;
      overflow: hidden;
    }
    
    /* Sidebar toggle */
    .sidebar-toggle {
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #8b949e;
      cursor: pointer;
      padding: 4px 8px;
      font-size: 14px;
      transition: all 0.2s;
    }
    .sidebar-toggle:hover {
      background: #30363d;
      color: #58a6ff;
    }
    
    /* Expand button */
    .expand-btn {
      position: absolute;
      top: 8px;
      left: 16px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #8b949e;
      cursor: pointer;
      padding: 6px 12px;
      font-size: 14px;
      transition: all 0.2s;
      z-index: 100;
      display: none;
    }
    .sidebar.collapsed ~ .content .expand-btn {
      display: block;
    }
    .expand-btn:hover {
      background: #30363d;
      color: #58a6ff;
    }
    
    /* Sidebar sections */
    .sidebar-section {
      margin-bottom: 20px;
    }
    .sidebar-section-title {
      font-size: 12px;
      font-weight: 600;
      color: #8b949e;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Session Info */
    .session-info {
      font-size: 13px;
    }
    .info-row {
      display: flex;
      margin-bottom: 8px;
    }
    .info-label {
      color: #8b949e;
      min-width: 70px;
      flex-shrink: 0;
    }
    .info-value {
      color: #c9d1d9;
      word-break: break-all;
    }
    
    /* Turn buttons */
    .turn-buttons {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .turn-btn {
      padding: 6px 10px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #8b949e;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      width: 100%;
      margin-bottom: 10px;
    }
    .turn-btn-id {
      font-weight: 600;
      color: #c9d1d9;
      font-size: 11px;
    }
    .turn-btn-message {
      font-size: 10px;
      color: #6e7681;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 2px;
    }
    .turn-btn:hover {
      background: #30363d;
      border-color: #58a6ff;
    }
    .turn-btn:hover .turn-btn-id {
      color: #58a6ff;
    }
    .turn-btn.active {
      background: #1f6feb;
      border-color: #1f6feb;
      color: #fff;
    }
    .turn-btn.active .turn-btn-id,
    .turn-btn.active .turn-btn-message {
      color: #fff;
    }
    
    /* Event filters */
    .event-filters {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .filter-btn {
      padding: 6px 10px;
      background: #21262d;
      border: 1px solid #30363d;
      border-radius: 4px;
      color: #c9d1d9;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
      text-align: left;
      width: 100%;
    }
    .filter-btn:not(:disabled):hover { 
      background: #30363d; 
    }
    .filter-btn.active {
      background: #1f6feb;
      border-color: #1f6feb;
      color: #fff;
    }
    .filter-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      background: #161b22;
      color: #6e7681;
    }
    
    /* Content */
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }
    
    .scroll-indicator {
      padding: 8px 12px;
      background: #0d1117;
      border-bottom: 1px solid #30363d;
      font-size: 12px;
      color: #8b949e;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .content-toolbar-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .content-toolbar-center {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      padding: 0 16px;
    }
    
    .search-input {
      width: 300px;
      padding: 4px 12px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }
    
    .search-input:focus {
      border-color: #58a6ff;
      background: #0d1117;
    }
    
    .search-input::placeholder {
      color: #6e7681;
    }
    
    /* Search highlight */
    .search-highlight {
      background: #ffd33d;
      color: #1f2328;
      padding: 1px 2px;
      border-radius: 2px;
      font-weight: 500;
    }
    
    .filter-dropdown {
      position: relative;
    }
    
    .filter-dropdown-toggle {
      padding: 4px 12px;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      color: #c9d1d9;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .filter-dropdown-toggle:hover {
      border-color: #58a6ff;
      background: #0d1117;
    }
    
    .filter-count {
      background: #58a6ff;
      color: #0d1117;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
    }
    
    .filter-dropdown-menu {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      min-width: 250px;
      z-index: 1000;
    }
    
    .filter-dropdown-header {
      padding: 8px 12px;
      border-bottom: 1px solid #30363d;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      font-weight: 600;
      color: #c9d1d9;
    }
    
    .clear-filters-btn {
      background: none;
      border: none;
      color: #58a6ff;
      cursor: pointer;
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 3px;
      transition: background 0.2s;
    }
    
    .clear-filters-btn:hover {
      background: rgba(88, 166, 255, 0.1);
    }
    
    .filter-options {
      max-height: 300px;
      overflow-y: auto;
      padding: 4px 0;
    }
    
    .filter-option {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 13px;
    }
    
    .filter-option:hover {
      background: rgba(88, 166, 255, 0.1);
    }
    
    .filter-option input[type="checkbox"] {
      cursor: pointer;
      accent-color: #58a6ff;
    }
    
    .filter-option-label {
      flex: 1;
      color: #c9d1d9;
    }
    
    .filter-option-count {
      color: #7d8590;
      font-size: 11px;
    }
    
    .content-toolbar-right {
      text-align: right;
    }
    
    /* Virtual Scroller */
    .vue-recycle-scroller {
      flex: 1;
    }
    .vue-recycle-scroller__item-wrapper {
      overflow: visible !important;
    }
    
    /* Events */
    .event {
      background: #161b22;
      border-left: 3px solid #30363d;
      border-bottom: 1px solid #21262d;
      padding: 6px 12px;
      margin: 0;
      border-radius: 3px;
      font-size: 14px;
    }
    .event.turn-boundary {
      background: #1c2128;
      border-left: 4px solid #8250df;
      padding: 8px 12px;
      box-shadow: 0 0 8px rgba(130, 80, 223, 0.15);
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }
    .event-badge {
      padding: 2px 8px;
      border-radius: 3px;
      font-size: 11px;
      font-weight: 600;
      white-space: nowrap;
      min-width: 90px;
      text-align: center;
      display: inline-block;
      line-height: 1.4;
    }
    .badge-user { background: #1f6feb; color: #fff; }
    .badge-assistant { background: #238636; color: #fff; }
    .badge-reasoning { background: #a371f7; color: #fff; }
    .badge-turn { background: #8250df; color: #fff; }
    .badge-tool { background: #9e6a03; color: #fff; }
    .badge-subagent { background: #8957e5; color: #fff; }
    .badge-skill { background: #bf3989; color: #fff; }
    .badge-session { background: #6e7681; color: #fff; }
    .badge-error { background: #da3633; color: #fff; }
    .badge-warning { background: #d29922; color: #000; }
    .badge-info { background: #58a6ff; color: #fff; }
    
    .event-content {
      color: #c9d1d9;
      text-align: left;
      font-size: 13px;
    }
    
    /* Markdown styling */
    .event-content code {
      background: #161b22;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 11px;
      color: #f0883e;
    }
    .event-content pre {
      background: #161b22;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 8px 0;
      border: 1px solid #30363d;
      font-size: 12px;
    }
    .event-content pre code {
      background: none;
      padding: 0;
      color: #e6edf3;
    }
    .event-content a {
      color: #58a6ff;
      text-decoration: none;
    }
    .event-content a:hover {
      text-decoration: underline;
    }
    .event-content ul, .event-content ol {
      padding-left: 24px;
      margin: 8px 0;
    }
    .event-content li {
      margin: 4px 0;
    }
    .event-content blockquote {
      border-left: 3px solid #30363d;
      padding-left: 12px;
      margin: 8px 0;
      color: #8b949e;
    }
    .event-content strong {
      color: #e6edf3;
      font-weight: 600;
    }
    .event-content em {
      color: #e6edf3;
      font-style: italic;
    }
    .event-content h1, .event-content h2, .event-content h3, 
    .event-content h4, .event-content h5, .event-content h6 {
      color: #e6edf3;
      margin: 12px 0 6px 0;
      font-weight: 600;
    }
    .event-content h1 { font-size: 16px; }
    .event-content h2 { font-size: 15px; }
    .event-content h3 { font-size: 14px; }
    .event-content h4 { font-size: 13px; }
    .event-content p {
      margin: 6px 0;
    }
    
    /* Markdown table styling */
    .event-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 12px 0;
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
    }
    .event-content th {
      background: #21262d;
      padding: 8px 12px;
      text-align: left;
      font-weight: 600;
      color: #e6edf3;
      border-bottom: 1px solid #30363d;
    }
    .event-content td {
      padding: 8px 12px;
      border-bottom: 1px solid #30363d;
    }
    .event-content tr:last-child td {
      border-bottom: none;
    }
    .event-content tbody tr:hover {
      background: rgba(110, 118, 129, 0.1);
    }
    
    .event-timestamp {
      font-size: 11px;
      color: #8b949e;
    }
    
    /* Tool calls */
    .tool-list {
      margin-top: 6px;
      padding-left: 8px;
      border-left: 2px solid rgba(110, 118, 129, 0.3);
    }
    .tool-item {
      padding: 2px 0;
    }
    .tool-header-line {
      color: #8b949e;
      font-size: 12px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      cursor: pointer;
      user-select: none;
      line-height: 1;
      display: flex;
      align-items: center;
      gap: 0;
      padding: 2px 0;
    }
    .tool-header-line:hover {
      color: #c9d1d9;
    }
    .tool-connector {
      color: #6e7681;
      margin-right: 0;
      flex-shrink: 0;
      line-height: 1;
    }
    .tool-expand-icon {
      color: #6e7681;
      margin: 0 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 12px;
      height: 12px;
      flex-shrink: 0;
      line-height: 1;
      transform: translateY(-1px);
    }
    .tool-name {
      color: #f0883e;
      flex-shrink: 0;
      margin-right: 4px;
    }
    .tool-status-success {
      color: #238636;
    }
    .tool-status-error {
      color: #da3633;
    }
    .tool-status-running {
      color: #d29922;
    }
    .tool-detail {
      margin-top: 4px;
      padding: 8px;
      background: rgba(110, 118, 129, 0.05);
      border-radius: 3px;
      border: 1px solid #30363d;
      font-size: 11px;
    }
    .tool-detail-section {
      margin-bottom: 6px;
    }
    .tool-detail-section:last-child {
      margin-bottom: 0;
    }
    .tool-detail-title {
      color: #7d8590;
      margin-bottom: 2px;
      font-weight: 600;
      font-size: 10px;
    }
    .tool-detail-content pre {
      margin: 0;
      padding: 4px 6px;
      background: #0d1117;
      border-radius: 3px;
      overflow-x: auto;
      max-height: 200px;
      font-size: 11px;
      line-height: 1.3;
      color: #e6edf3;
    }
    
    /* Turn divider */
    .turn-divider {
      display: flex;
      align-items: center;
      color: #8250df;
      margin: 0;
      padding: 0;
      position: relative;
      z-index: 1000;
      background: #0d1117;
    }
    .turn-divider-line-left {
      flex: 1;
      height: 1px;
      background: linear-gradient(to right, transparent, #8250df, #8250df);
    }
    .turn-divider-text {
      padding: 0 12px;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
    }
    .turn-divider-line-right {
      flex: 1;
      height: 1px;
      background: linear-gradient(to left, transparent, #8250df, #8250df);
    }
    
    /* Subagent divider */
    .subagent-divider {
      display: flex;
      align-items: center;
      margin: 0;
      padding: 0;
      position: relative;
      z-index: 1000;
      background: #0d1117;
    }
    .subagent-divider.started {
      color: #f0b429;
    }
    .subagent-divider.completed {
      color: #f0b429;
    }
    .subagent-divider.failed {
      color: #f85149;
    }
    .subagent-divider-line-left {
      flex: 1;
      height: 1px;
    }
    .subagent-divider.started .subagent-divider-line-left {
      background: linear-gradient(to right, transparent, #f0b429, #f0b429);
    }
    .subagent-divider.completed .subagent-divider-line-left {
      background: linear-gradient(to right, transparent, #f0b429, #f0b429);
    }
    .subagent-divider.failed .subagent-divider-line-left {
      background: linear-gradient(to right, transparent, #f85149, #f85149);
    }
    .subagent-divider-text {
      padding: 0 12px;
      font-size: 12px;
      font-weight: 600;
      white-space: nowrap;
    }
    .subagent-divider-line-right {
      flex: 1;
      height: 1px;
    }
    .subagent-divider.started .subagent-divider-line-right {
      background: linear-gradient(to left, transparent, #f0b429, #f0b429);
    }
    .subagent-divider.completed .subagent-divider-line-right {
      background: linear-gradient(to left, transparent, #f0b429, #f0b429);
    }
    .subagent-divider.failed .subagent-divider-line-right {
      background: linear-gradient(to left, transparent, #f85149, #f85149);
    }
  </style>
</head>
<body>
  <div id="app"></div>
  
  <!-- Session data -->
  <script>
    window.sessionData = {
      sessionId: '<%= sessionId %>',
      metadata: <%- JSON.stringify(metadata) %>,
      events: [] // Will be loaded asynchronously
    };
  </script>
  
  <!-- Vue App -->
  <script>
    const { createApp, ref, computed, onMounted, reactive } = Vue;
    const { DynamicScroller, DynamicScrollerItem } = window.VueVirtualScroller;
    
    const app = createApp({
      components: {
        DynamicScroller,
        DynamicScrollerItem
      },
      
      setup() {
        const sessionId = ref(window.sessionData.sessionId);
        const metadata = ref(window.sessionData.metadata);
        const sidebarCollapsed = ref(false);
        const expandedTools = reactive(new Set());
        const expandedContent = reactive(new Set());
        const currentFilter = ref('all');
        const searchText = ref('');
        const activeTurnIndex = ref(0);
        const scrollerRef = ref(null);
        const visibleRange = ref({ start: 0, end: 0 });
        
        // Async loading state
        const loadedEvents = ref([]);
        const eventsLoading = ref(true);
        const eventsError = ref(null);
        
        // Flatten and sort events
        const flatEvents = computed(() => {
          return loadedEvents.value
            .filter(e => 
              e.type !== 'assistant.turn_end' && 
              e.type !== 'assistant.turn_complete' &&
              e.type !== 'session.start'  // Filter out session.start (info shown in sidebar)
            )
            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
            .map((e, index) => ({ ...e, virtualIndex: index }));
        });
        
        // Helper: check if event matches search
        const matchesSearch = (e) => {
          if (!searchText.value.trim()) return true;
          
          const search = searchText.value.toLowerCase();
          // Only search in event.data fields, not type
          const content = [
            e.data?.message,
            e.data?.text,
            e.data?.content,
            e.data?.reason,
            e.data?.errorType
          ].filter(Boolean).join(' ').toLowerCase();
          
          return content.includes(search);
        };
        
        // Events after search (before type filter) - used for filter counts
        const searchFilteredEvents = computed(() => {
          const excludeToolCalls = (e) => {
            const eventType = e.type || '';
            return eventType !== 'tool.execution_start' && eventType !== 'tool.execution_complete';
          };
          
          let events = flatEvents.value.filter(excludeToolCalls);
          
          // Apply search only
          if (searchText.value.trim()) {
            events = events.filter(matchesSearch);
          }
          
          return events;
        });
        
        // Final filtered events (search + type filter)
        const filteredEvents = computed(() => {
          let events = searchFilteredEvents.value;
          
          // Apply type filter
          if (currentFilter.value !== 'all') {
            events = events.filter(e => e.type === currentFilter.value);
          }
          
          return events;
        });
        
        // Event type counts (based on search results)
        const eventCounts = computed(() => {
          const counts = {};
          searchFilteredEvents.value.forEach(e => {
            if (e.type) {
              counts[e.type] = (counts[e.type] || 0) + 1;
            }
          });
          return counts;
        });
        
        // Available filters (with counts based on search results)
        const filters = computed(() => {
          const types = new Set(searchFilteredEvents.value.map(e => e.type).filter(Boolean));
          
          const totalEvents = searchFilteredEvents.value.length;
          
          const result = [{ type: 'all', label: `All (${totalEvents})`, count: totalEvents }];
          
          const commonTypes = ['user.message', 'assistant.message', 'assistant.reasoning', 
            'assistant.turn_start', 'skill.invoked', 'subagent.started', 'subagent.completed', 'subagent.failed', 
            'abort', 'session.error'];
          
          commonTypes.forEach(type => {
            const count = eventCounts.value[type] || 0;
            result.push({
              type,
              label: `${type} (${count})`,
              count,
              disabled: count === 0
            });
          });
          
          return result;
        });
        
        // Turns
        const turns = computed(() => {
          const turnStarts = flatEvents.value.filter(e => e.type === 'assistant.turn_start');
          const allUserMessages = flatEvents.value.filter(e => e.type === 'user.message');
          
          return turnStarts.map((turn, idx) => {
            // Use idx as the display turn number (sequential, no duplicates)
            const turnId = idx;
            const startTime = new Date(turn.timestamp).getTime();
            
            // Find turn end
            let endTime;
            const nextTurnIndex = turnStarts.indexOf(turn) + 1;
            if (nextTurnIndex < turnStarts.length) {
              endTime = new Date(turnStarts[nextTurnIndex].timestamp).getTime();
            } else {
              endTime = Date.now();
            }
            
            // Calculate duration
            const durationMs = endTime - startTime;
            const totalSeconds = Math.floor(durationMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const durationText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
            
            // Find user message before this turn
            const userMessage = flatEvents.value
              .slice(0, flatEvents.value.indexOf(turn))
              .reverse()
              .find(e => e.type === 'user.message');
            
            // Calculate UserReq number (1-indexed)
            const userReqNumber = userMessage 
              ? allUserMessages.indexOf(userMessage) + 1 
              : 0;
            
            return {
              id: turnId,
              index: turn.virtualIndex,
              originalTurnId: turn.data?.turnId,  // Keep original for reference
              timestamp: turn.timestamp,
              duration: durationText,
              message: userMessage?.data?.message || '',
              userReqNumber: userReqNumber
            };
          });
        });
        
        // Tool call map
        const toolCallMap = computed(() => {
          const map = new Map();
          const toolGroups = new Map();
          
          flatEvents.value.forEach(event => {
            if (event.type === 'tool.execution_start') {
              const toolId = event.data?.toolCallId;
              if (toolId) {
                if (!toolGroups.has(toolId)) {
                  toolGroups.set(toolId, { tool: event.data.tool, start: event });
                }
              }
            } else if (event.type === 'tool.execution_complete') {
              const toolId = event.data?.toolCallId;
              if (toolId && toolGroups.has(toolId)) {
                toolGroups.get(toolId).complete = event;
              }
            }
          });
          
          flatEvents.value.forEach(event => {
            if (event.type === 'assistant.message') {
              const groups = [];
              toolGroups.forEach((group, toolId) => {
                if (group.start?.parentId === event.id) {
                  groups.push(group);
                }
              });
              if (groups.length > 0) {
                map.set(event.id || event.virtualIndex, groups);
              }
            }
          });
          
          return map;
        });
        
        // Methods
        const formatTime = (timestamp) => {
          if (!timestamp) return '';
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const seconds = String(date.getSeconds()).padStart(2, '0');
          return `${hours}:${minutes}:${seconds}`;
        };
        
        const renderMarkdown = (text) => {
          if (!text) return '';
          try {
            // å¤„ç†è½¬ä¹‰åºåˆ—ï¼šå°† \r\nã€\nã€\t ç­‰è½¬æ¢ä¸ºå®žé™…å­—ç¬¦
            let processedText = text
              .replace(/\\r\\n/g, '\n')  // \r\n â†’ æ¢è¡Œ
              .replace(/\\n/g, '\n')      // \n â†’ æ¢è¡Œ
              .replace(/\\t/g, '\t')      // \t â†’ åˆ¶è¡¨ç¬¦
              .replace(/\\"/g, '"')       // \" â†’ å¼•å·
              .replace(/\\\\/g, '\\');    // \\ â†’ åæ–œæ 
            
            // Parse YAML frontmatter
            const frontmatterMatch = processedText.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
            if (frontmatterMatch) {
              const frontmatter = frontmatterMatch[1];
              const content = frontmatterMatch[2];
              
              // Parse frontmatter into key-value pairs
              const pairs = frontmatter.split('\n').filter(line => line.trim() && line.includes(':')).map(line => {
                const colonIndex = line.indexOf(':');
                const key = line.substring(0, colonIndex).trim();
                const value = line.substring(colonIndex + 1).trim();
                return { key, value };
              });
              
              // Render frontmatter as table
              let tableHTML = '<table style="margin-bottom: 16px; border-collapse: collapse;"><tbody>';
              pairs.forEach(pair => {
                tableHTML += `<tr><td style="padding: 4px 12px; border: 1px solid #30363d; font-weight: 600; color: #7d8590;">${pair.key}</td><td style="padding: 4px 12px; border: 1px solid #30363d;">${pair.value}</td></tr>`;
              });
              tableHTML += '</tbody></table>';
              
              // Render remaining content
              return tableHTML + marked.parse(content);
            }
            
            return marked.parse(processedText);
          } catch (e) {
            return text;
          }
        };
        
        const toggleTool = (toolId) => {
          if (expandedTools.has(toolId)) {
            expandedTools.delete(toolId);
          } else {
            expandedTools.add(toolId);
          }
        };
        
        const highlightSearchText = (html, searchTerm) => {
          if (!searchTerm || !searchTerm.trim() || !html) return html;
          
          const term = searchTerm.trim();
          // Escape special regex characters
          const escapedTerm = term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          
          // Create a temporary element to parse HTML
          const temp = document.createElement('div');
          temp.innerHTML = html;
          
          // Function to highlight text in text nodes
          const highlightTextNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent;
              const regex = new RegExp(`(${escapedTerm})`, 'gi');
              if (regex.test(text)) {
                const highlighted = text.replace(regex, '<mark class="search-highlight">$1</mark>');
                const span = document.createElement('span');
                span.innerHTML = highlighted;
                node.parentNode.replaceChild(span, node);
              }
            } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName !== 'SCRIPT' && node.tagName !== 'STYLE') {
              Array.from(node.childNodes).forEach(highlightTextNode);
            }
          };
          
          Array.from(temp.childNodes).forEach(highlightTextNode);
          return temp.innerHTML;
        };
        
        const toggleContent = (contentId) => {
          if (expandedContent.has(contentId)) {
            expandedContent.delete(contentId);
          } else {
            expandedContent.add(contentId);
          }
        };
        
        const isContentTooLong = (text) => {
          if (!text) return false;
          const lineCount = text.split('\n').length;
          return lineCount > 20 || text.length > 2000;
        };
        
        const truncateContent = (text) => {
          const lines = text.split('\n');
          if (lines.length <= 20) return text;
          return lines.slice(0, 20).join('\n') + '\n\n...';
        };
        
        const getBadgeInfo = (type) => {
          // Special case for specific event types
          if (type === 'session.model_change') {
            return { label: 'MODEL CHANGE', class: 'badge-session' };
          }
          
          const parts = (type || '').split('.');
          const category = parts[0] || 'unknown';
          
          const badges = {
            user: { label: 'USER', class: 'badge-user' },
            assistant: { label: 'ASSISTANT', class: 'badge-assistant' },
            reasoning: { label: 'REASONING', class: 'badge-reasoning' },
            turn: { label: 'TURN', class: 'badge-turn' },
            tool: { label: 'TOOL', class: 'badge-tool' },
            subagent: { label: 'SUBAGENT', class: 'badge-subagent' },
            skill: { label: 'SKILL', class: 'badge-skill' },
            session: { label: 'SESSION', class: 'badge-session' },
            error: { label: 'ERROR', class: 'badge-error' },
            abort: { label: 'ABORT', class: 'badge-error' }
          };
          
          return badges[category] || { label: category.toUpperCase(), class: 'badge-info' };
        };
        
        const getToolStatus = (group) => {
          if (!group.complete) {
            return { icon: 'â³', color: 'tool-status-running', text: '' };
          }
          
          const completeData = group.complete.data || {};
          if (completeData.error || completeData.isError) {
            return { icon: 'âŒ', color: 'tool-status-error', text: '' };
          }
          
          return { icon: 'âœ“', color: 'tool-status-success', text: '' };
        };
        
        const getToolErrorMessage = (group) => {
          if (!group.complete?.data?.error) return '';
          
          const error = group.complete.data.error;
          
          // If error is an object with message property
          if (typeof error === 'object' && error.message) {
            return error.message;
          }
          
          // If error is a string, try to parse as JSON
          if (typeof error === 'string') {
            try {
              const parsed = JSON.parse(error);
              if (parsed.message) return parsed.message;
            } catch (e) {
              // Not JSON, return as-is
            }
            return error;
          }
          
          // Fallback to stringified error
          return String(error);
        };
        
        const getToolDuration = (group) => {
          if (!group.complete) return '';
          
          const startTime = new Date(group.start.timestamp).getTime();
          const endTime = new Date(group.complete.timestamp).getTime();
          const durationMs = endTime - startTime;
          
          if (durationMs >= 100) {
            return `${(durationMs / 1000).toFixed(1)}s`;
          }
          return '';
        };
        
        const getToolCommand = (group) => {
          if (!group.start) return '';
          const args = group.start.data?.arguments || {};
          const toolName = group.start.data?.toolName || group.tool || '';
          
          let command = '';
          if (toolName === 'bash' || toolName === 'exec') {
            command = args.command || args.description || '';
          } else if (toolName === 'ask_user') {
            command = args.question || args.message || '';
          } else if (toolName === 'read' || toolName === 'write' || toolName === 'edit') {
            command = args.file_path || args.path || '';
          } else if (toolName === 'view') {
            command = args.path || args.file || '';
          } else if (toolName === 'create') {
            command = args.path || args.name || '';
          } else if (toolName === 'report_intent') {
            command = args.intent || args.message || '';
          } else if (toolName === 'web_search') {
            command = args.query || '';
          } else if (toolName === 'web_fetch') {
            command = args.url || '';
          } else if (toolName === 'browser') {
            const action = args.action || '';
            const url = args.targetUrl || args.url || '';
            command = url ? `${action} ${url}` : action;
          } else {
            command = args.description || args.command || args.message || 
                      args.path || args.file_path || args.query || '';
          }
          
          if (command && command.length > 100) {
            command = command.substring(0, 100) + '...';
          }
          
          return command;
        };
        
        const hasTools = (event) => {
          return event.type === 'assistant.message' && toolCallMap.value.has(event.id || event.virtualIndex);
        };
        
        const getToolGroups = (event) => {
          return toolCallMap.value.get(event.id || event.virtualIndex) || [];
        };
        
        const setFilter = (type) => {
          currentFilter.value = type;
        };
        
        const scrollToTurn = (turn) => {
          // Clear search and filter when jumping to a turn
          searchText.value = '';
          currentFilter.value = 'all';
          
          activeTurnIndex.value = turn.index;
          
          // Wait for DOM to update and virtual scroller to re-calculate
          Vue.nextTick(() => {
            if (scrollerRef.value) {
              // Use turn.index (virtualIndex) to find the exact turn_start event
              const targetIndex = filteredEvents.value.findIndex(e => 
                e.virtualIndex === turn.index
              );
              
              if (targetIndex >= 0) {
                // Additional small delay to ensure scroller is ready
                setTimeout(() => {
                  scrollerRef.value.scrollToItem(targetIndex);
                }, 50);
              }
            }
          });
        };
        
        const getTurnNumber = (virtualIndex) => {
          // Find the turn with matching virtualIndex
          const turn = turns.value.find(t => t.index === virtualIndex);
          if (!turn) return '?';
          
          // Format: "UserReq N - Turn M" or just "Turn M" if no UserReq
          if (turn.userReqNumber > 0) {
            return `${turn.userReqNumber} - Turn ${turn.id}`;
          }
          return `Turn ${turn.id}`;
        };
        
        const exportSession = () => {
          // Build tool call groups (same as page rendering)
          const eventList = flatEvents.value;
          const toolGroups = new Map();
          
          // First pass: group tool events by toolCallId
          eventList.forEach((e, idx) => {
            if (e.type === 'tool.execution_start') {
              const toolCallId = e.data?.toolCallId || e.id;
              if (!toolGroups.has(toolCallId)) {
                toolGroups.set(toolCallId, { start: null, complete: null, parentEvent: null });
              }
              toolGroups.get(toolCallId).start = e;
            } else if (e.type === 'tool.execution_complete') {
              const toolCallId = e.data?.toolCallId || e.id;
              if (!toolGroups.has(toolCallId)) {
                toolGroups.set(toolCallId, { start: null, complete: null, parentEvent: null });
              }
              toolGroups.get(toolCallId).complete = e;
            }
          });
          
          // Second pass: link tool groups to their parent assistant messages
          const eventToolMap = new Map();
          eventList.forEach(event => {
            if (event.type === 'assistant.message') {
              const relatedTools = [];
              toolGroups.forEach((group, toolCallId) => {
                if (group.start?.parentId === event.id) {
                  relatedTools.push(group);
                }
              });
              if (relatedTools.length > 0) {
                eventToolMap.set(event.id || event.virtualIndex, relatedTools);
              }
            }
          });
          
          // Helper function to render Markdown using marked
          const renderMarkdownForExport = (text) => {
            if (!text) return '';
            try {
              // Process escape sequences
              let processedText = text
                .replace(/\\r\\n/g, '\n')
                .replace(/\\n/g, '\n')
                .replace(/\\t/g, '\t')
                .replace(/\\"/g, '"')
                .replace(/\\\\/g, '\\');
              
              // Parse YAML frontmatter
              const frontmatterMatch = processedText.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
              if (frontmatterMatch) {
                const frontmatter = frontmatterMatch[1];
                const content = frontmatterMatch[2];
                
                const pairs = frontmatter.split('\n').filter(line => line.trim() && line.includes(':')).map(line => {
                  const colonIndex = line.indexOf(':');
                  const key = line.substring(0, colonIndex).trim();
                  const value = line.substring(colonIndex + 1).trim();
                  return { key, value };
                });
                
                let tableHTML = '<table style="margin-bottom: 16px; border-collapse: collapse; width: 100%;"><tbody>';
                pairs.forEach(pair => {
                  tableHTML += `<tr><td style="padding: 6px 12px; border: 1px solid #30363d; font-weight: 600; color: #7d8590; background: #161b22;">${escapeHtml(pair.key)}</td><td style="padding: 6px 12px; border: 1px solid #30363d; color: #c9d1d9;">${escapeHtml(pair.value)}</td></tr>`;
                });
                tableHTML += '</tbody></table>';
                
                return tableHTML + marked.parse(content);
              }
              
              return marked.parse(processedText);
            } catch (e) {
              console.error('Markdown rendering error:', e);
              return escapeHtml(text).replace(/\n/g, '<br>');
            }
          };
          
          // Generate events HTML with full details
          const eventsHtml = eventList.map((event, idx) => {
            // Skip individual tool events (rendered as groups under assistant messages)
            if (event.type === 'tool.execution_start' || event.type === 'tool.execution_complete') {
              return '';
            }
            
            let html = '';
            
            // Turn divider
            if (event.type === 'assistant.turn_start') {
              const turnNum = getTurnNumber(event.virtualIndex);
              html += `<div class="turn-divider">
  <div class="turn-divider-line"></div>
  <span class="turn-divider-text">UserReq ${turnNum} Start</span>
  <div class="turn-divider-line"></div>
</div>\n`;
            }
            
            // Subagent divider
            if (event.type === 'subagent.started' || event.type === 'subagent.completed' || event.type === 'subagent.failed') {
              const status = event.type.split('.')[1];
              const statusIcon = status === 'started' ? 'â–¶' : status === 'completed' ? 'âœ“' : 'âœ—';
              const agentName = event.data?.agentDisplayName || event.data?.agentName || 'SubAgent';
              html += `<div class="subagent-divider ${status}">
  <div class="subagent-divider-line"></div>
  <span class="subagent-divider-text">ðŸ¤– ${escapeHtml(agentName)} ${statusIcon}</span>
  <div class="subagent-divider-line"></div>
</div>\n`;
            }
            
            const badge = getBadgeInfo(event.type);
            
            html += '<div class="event">\n';
            html += `  <div class="event-header">
    <span class="event-badge ${badge.class}">${badge.label}</span>
    <span class="event-time">${formatTimestamp(event.timestamp)}</span>
  </div>\n`;
            
            // Event content based on type
            if (event.type === 'abort' && event.data?.reason) {
              html += `  <div class="event-content"><strong>Reason:</strong> ${escapeHtml(event.data.reason)}</div>\n`;
            } else if (event.type === 'session.start') {
              if (event.data?.type) html += `  <div class="event-content"><strong>Type:</strong> ${escapeHtml(event.data.type)}</div>\n`;
              if (event.data?.selectedModel) html += `  <div class="event-content"><strong>Model:</strong> ${escapeHtml(event.data.selectedModel)}</div>\n`;
              if (event.data?.producer) html += `  <div class="event-content"><strong>Producer:</strong> ${escapeHtml(event.data.producer)}</div>\n`;
            } else if (event.type === 'session.resume') {
              if (event.data?.resumeTime) html += `  <div class="event-content"><strong>Resume Time:</strong> ${formatDateTime(event.data.resumeTime)}</div>\n`;
              if (event.data?.eventCount) html += `  <div class="event-content"><strong>Event Count:</strong> ${event.data.eventCount}</div>\n`;
              if (event.data?.context?.branch) html += `  <div class="event-content"><strong>Branch:</strong> ${escapeHtml(event.data.context.branch)}</div>\n`;
              if (event.data?.context?.repository) html += `  <div class="event-content"><strong>Repository:</strong> ${escapeHtml(event.data.context.repository)}</div>\n`;
              if (event.data?.context?.cwd) html += `  <div class="event-content"><strong>CWD:</strong> ${escapeHtml(event.data.context.cwd)}</div>\n`;
            } else if (event.type === 'session.error') {
              if (event.data?.errorType) html += `  <div class="event-content"><strong>Error Type:</strong> ${escapeHtml(event.data.errorType)}</div>\n`;
              if (event.data?.message) html += `  <div class="event-content"><strong>Message:</strong> ${escapeHtml(event.data.message)}</div>\n`;
            } else if (event.data?.message || event.data?.text || event.data?.content) {
              const content = event.data?.message || event.data?.text || event.data?.content;
              html += `  <div class="event-content">${renderMarkdownForExport(content)}</div>\n`;
            }
            
            // Tool calls for this event
            const eventTools = eventToolMap.get(event.id || event.virtualIndex) || [];
            if (eventTools.length > 0) {
              html += '  <div class="tool-calls">\n';
              eventTools.forEach((group, toolIdx) => {
                const toolData = group.start?.data || {};
                const toolName = toolData.toolName || 'unknown';
                const status = getToolStatus(group);
                const duration = getToolDuration(group);
                const command = getToolCommand(group);
                const errorMsg = getToolErrorMessage(group);
                
                html += `    <div class="tool-call-item">
      <div class="tool-call-header">
        <span class="tool-icon">ðŸ”§</span>
        <span class="tool-name">${escapeHtml(toolName)}</span>
        <span class="tool-status ${status.color}">${status.icon}${duration ? ' ' + duration : ''}</span>
        ${command ? `<span class="tool-command">${escapeHtml(command)}</span>` : ''}
      </div>\n`;
                
                // Arguments (always show if available)
                if (toolData.arguments) {
                  html += `      <div class="tool-detail-section">
        <div class="tool-detail-title">Arguments:</div>
        <div class="tool-detail-content"><pre><code>${escapeHtml(JSON.stringify(toolData.arguments, null, 2))}</code></pre></div>
      </div>\n`;
                }
                
                // Result (always show if available)
                const result = group.complete?.data?.result;
                if (result) {
                  html += `      <div class="tool-detail-section">
        <div class="tool-detail-title">Result:</div>
        <div class="tool-detail-content"><pre><code>${escapeHtml(JSON.stringify(result, null, 2))}</code></pre></div>
      </div>\n`;
                }
                
                // Error (always show if available)
                if (errorMsg) {
                  html += `      <div class="tool-detail-section tool-error">
        <div class="tool-detail-title">Error:</div>
        <div class="tool-detail-content" style="color: #ff7b72;"><pre><code>${escapeHtml(errorMsg)}</code></pre></div>
      </div>\n`;
                }
                
                html += '    </div>\n';
              });
              html += '  </div>\n';
            }
            
            html += '</div>\n';
            return html;
          }).filter(h => h).join('');
          
          // Generate full HTML with comprehensive styles (GitHub dark theme)
          const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Session ${sessionId.value} - Export</title>
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      line-height: 1.6;
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 { color: #58a6ff; margin-bottom: 20px; font-size: 26px; font-weight: 600; }
    h2 { color: #e6edf3; font-size: 18px; margin: 24px 0 12px; font-weight: 600; }
    
    /* Session Info */
    .session-info {
      background: #161b22;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 16px;
      margin-bottom: 24px;
    }
    .info-row {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      font-size: 14px;
    }
    .info-label {
      color: #8b949e;
      min-width: 100px;
      font-weight: 600;
      flex-shrink: 0;
    }
    .info-value { 
      color: #c9d1d9; 
      word-break: break-word;
    }
    
    /* Turn Divider */
    .turn-divider {
      display: flex;
      align-items: center;
      margin: 24px 0;
      color: #8250df;
    }
    .turn-divider-line {
      flex: 1;
      height: 2px;
      background: linear-gradient(to right, transparent, #8250df 20%, #8250df 80%, transparent);
    }
    .turn-divider-text {
      padding: 0 16px;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    /* Subagent Divider */
    .subagent-divider {
      display: flex;
      align-items: center;
      margin: 20px 0;
    }
    .subagent-divider.started { color: #f0b429; }
    .subagent-divider.completed { color: #3fb950; }
    .subagent-divider.failed { color: #f85149; }
    .subagent-divider-line {
      flex: 1;
      height: 1px;
    }
    .subagent-divider.started .subagent-divider-line {
      background: linear-gradient(to right, transparent, #f0b429 20%, #f0b429 80%, transparent);
    }
    .subagent-divider.completed .subagent-divider-line {
      background: linear-gradient(to right, transparent, #3fb950 20%, #3fb950 80%, transparent);
    }
    .subagent-divider.failed .subagent-divider-line {
      background: linear-gradient(to right, transparent, #f85149 20%, #f85149 80%, transparent);
    }
    .subagent-divider-text {
      padding: 0 16px;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
    }
    
    /* Events */
    .event {
      background: #161b22;
      border: 1px solid #30363d;
      border-left: 3px solid #30363d;
      border-radius: 6px;
      padding: 14px;
      margin-bottom: 12px;
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .event-badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
      min-width: 95px;
      text-align: center;
      letter-spacing: 0.5px;
    }
    .badge-user { background: #1f6feb; color: #fff; }
    .badge-assistant { background: #238636; color: #fff; }
    .badge-reasoning { background: #a371f7; color: #fff; }
    .badge-turn { background: #8250df; color: #fff; }
    .badge-tool { background: #9e6a03; color: #fff; }
    .badge-subagent { background: #8957e5; color: #fff; }
    .badge-skill { background: #bf3989; color: #fff; }
    .badge-session { background: #6e7681; color: #fff; }
    .badge-error { background: #da3633; color: #fff; }
    .badge-warning { background: #d29922; color: #000; }
    .event-time {
      color: #7d8590;
      font-size: 12px;
      font-family: "SF Mono", Monaco, "Consolas", "Liberation Mono", monospace;
      margin-left: auto;
    }
    
    /* Event Content - Markdown Styling */
    .event-content {
      color: #c9d1d9;
      font-size: 14px;
      line-height: 1.6;
    }
    .event-content p {
      margin: 8px 0;
    }
    .event-content strong {
      color: #e6edf3;
      font-weight: 600;
    }
    .event-content em {
      font-style: italic;
    }
    .event-content code {
      background: #1c2128;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: "SF Mono", Monaco, "Consolas", monospace;
      font-size: 12px;
      color: #f0883e;
    }
    .event-content pre {
      background: #161b22;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 12px 0;
      border: 1px solid #30363d;
    }
    .event-content pre code {
      background: none;
      padding: 0;
      color: #e6edf3;
      font-size: 12px;
      line-height: 1.5;
    }
    .event-content a {
      color: #58a6ff;
      text-decoration: none;
    }
    .event-content a:hover {
      text-decoration: underline;
    }
    .event-content ul, .event-content ol {
      padding-left: 28px;
      margin: 10px 0;
    }
    .event-content li {
      margin: 6px 0;
    }
    .event-content blockquote {
      border-left: 3px solid #30363d;
      padding-left: 14px;
      margin: 12px 0;
      color: #8b949e;
    }
    .event-content h1, .event-content h2, .event-content h3,
    .event-content h4, .event-content h5, .event-content h6 {
      color: #e6edf3;
      margin: 16px 0 8px 0;
      font-weight: 600;
      line-height: 1.25;
    }
    .event-content h1 { font-size: 18px; border-bottom: 1px solid #30363d; padding-bottom: 8px; }
    .event-content h2 { font-size: 16px; border-bottom: 1px solid #30363d; padding-bottom: 6px; }
    .event-content h3 { font-size: 15px; }
    .event-content h4 { font-size: 14px; }
    .event-content h5 { font-size: 13px; }
    .event-content h6 { font-size: 12px; color: #8b949e; }
    
    /* Markdown Tables */
    .event-content table {
      border-collapse: collapse;
      width: 100%;
      margin: 12px 0;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 6px;
      overflow: hidden;
    }
    .event-content th {
      background: #161b22;
      padding: 8px 12px;
      text-align: left;
      font-weight: 600;
      color: #e6edf3;
      border-bottom: 2px solid #30363d;
      font-size: 13px;
    }
    .event-content td {
      padding: 8px 12px;
      border-bottom: 1px solid #30363d;
      font-size: 13px;
    }
    .event-content tr:last-child td {
      border-bottom: none;
    }
    .event-content tbody tr:hover {
      background: rgba(110, 118, 129, 0.08);
    }
    
    /* Tool Calls */
    .tool-calls {
      margin-top: 12px;
      border-left: 2px solid rgba(110, 118, 129, 0.3);
      padding-left: 12px;
    }
    .tool-call-item {
      background: #1c2128;
      border-left: 3px solid #6e7681;
      padding: 12px;
      margin-bottom: 10px;
      border-radius: 4px;
    }
    .tool-call-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .tool-icon { font-size: 16px; }
    .tool-name {
      font-weight: 600;
      color: #58a6ff;
      font-family: "SF Mono", Monaco, "Consolas", monospace;
    }
    .tool-status {
      font-size: 14px;
      font-weight: 600;
      margin-left: 4px;
    }
    .tool-status-success { color: #3fb950; }
    .tool-status-error { color: #ff7b72; }
    .tool-status-running { color: #f0b429; }
    .tool-command {
      color: #8b949e;
      font-family: "SF Mono", Monaco, "Consolas", monospace;
      font-size: 12px;
      flex: 1 1 auto;
      word-break: break-word;
    }
    .tool-detail-section {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #30363d;
    }
    .tool-detail-section.tool-error {
      background: rgba(248, 81, 73, 0.05);
      border-left: 3px solid #f85149;
      padding: 8px;
      margin-left: -12px;
      margin-right: -12px;
      padding-left: 20px;
      padding-right: 12px;
    }
    .tool-detail-title {
      font-weight: 600;
      color: #8b949e;
      font-size: 11px;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .tool-detail-content pre {
      background: #0d1117;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 11px;
      max-height: 600px;
      overflow-y: auto;
      border: 1px solid #30363d;
      line-height: 1.5;
    }
    .tool-detail-content code {
      color: #c9d1d9;
      font-family: "SF Mono", Monaco, "Consolas", monospace;
    }
    
    /* Print Styles */
    @media print {
      body { background: white; color: black; }
      .event, .session-info { break-inside: avoid; }
      .tool-call-item { break-inside: avoid; }
      .turn-divider { page-break-after: avoid; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ“‹ Session Export: ${escapeHtml(sessionId.value)}</h1>
    
    <div class="session-info">
      <h2>Session Information</h2>
      <div class="info-row">
        <div class="info-label">Model:</div>
        <div class="info-value">${escapeHtml(metadata.value.model || 'N/A')}</div>
      </div>
      ${metadata.value.repo ? `<div class="info-row">
        <div class="info-label">Repository:</div>
        <div class="info-value">${escapeHtml(metadata.value.repo)}</div>
      </div>` : ''}
      ${metadata.value.branch ? `<div class="info-row">
        <div class="info-label">Branch:</div>
        <div class="info-value">${escapeHtml(metadata.value.branch)}</div>
      </div>` : ''}
      ${metadata.value.cwd ? `<div class="info-row">
        <div class="info-label">Working Dir:</div>
        <div class="info-value">${escapeHtml(metadata.value.cwd)}</div>
      </div>` : ''}
      <div class="info-row">
        <div class="info-label">Created:</div>
        <div class="info-value">${formatDateTime(metadata.value.created)}</div>
      </div>
      <div class="info-row">
        <div class="info-label">Updated:</div>
        <div class="info-value">${formatDateTime(metadata.value.updated)}</div>
      </div>
      <div class="info-row">
        <div class="info-label">Total Events:</div>
        <div class="info-value">${eventList.filter(e => e.type !== 'tool.execution_start' && e.type !== 'tool.execution_complete').length}</div>
      </div>
    </div>
    
    <h2>Session Events</h2>
    ${eventsHtml}
    
    <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #30363d; text-align: center; color: #7d8590; font-size: 12px;">
      <p>Exported on ${new Date().toLocaleString()}</p>
      <p>Generated by copilot-session-viewer</p>
    </div>
  </div>
</body>
</html>`;
          
          // Trigger download
          const blob = new Blob([html], { type: 'text/html' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `session-${sessionId.value}-${new Date().toISOString().split('T')[0]}.html`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          console.log('âœ… Session exported successfully');
        };
        
        const escapeHtml = (text) => {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        };
        
        const formatDateTime = (timestamp) => {
          if (!timestamp) return 'N/A';
          return new Date(timestamp).toLocaleString();
        };
        
        const formatTimestamp = (timestamp) => {
          if (!timestamp) return '';
          const date = new Date(timestamp);
          const hours = String(date.getHours()).padStart(2, '0');
          const minutes = String(date.getMinutes()).padStart(2, '0');
          const seconds = String(date.getSeconds()).padStart(2, '0');
          return `${hours}:${minutes}:${seconds}`;
        };
        
        // Lifecycle
        onMounted(async () => {
          // Load events asynchronously
          try {
            const response = await fetch(`/api/session/${sessionId.value}/events`);
            if (!response.ok) {
              throw new Error(`Failed to load events: ${response.statusText}`);
            }
            loadedEvents.value = await response.json();
          } catch (error) {
            console.error('Error loading events:', error);
            eventsError.value = error.message;
          } finally {
            eventsLoading.value = false;
          }
          
          window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'b') {
              e.preventDefault();
              sidebarCollapsed.value = !sidebarCollapsed.value;
            }
          });
          
          if (window.marked) {
            marked.setOptions({
              breaks: true,
              gfm: true,
              sanitize: false
            });
          }
          
          // ç›‘å¬æ»šåŠ¨äº‹ä»¶æ¥æ›´æ–° visibleRange
          const updateVisibleRange = () => {
            if (!scrollerRef.value) return;
            
            // å°è¯•å¤šç§æ–¹å¼è®¿é—® scroller å…ƒç´ 
            let scroller = null;
            if (scrollerRef.value.$el) {
              scroller = scrollerRef.value.$el.querySelector('.vue-recycle-scroller');
            } else if (scrollerRef.value.querySelector) {
              scroller = scrollerRef.value.querySelector('.vue-recycle-scroller');
            }
            
            if (!scroller) {
              // å¦‚æžœè¿˜æ‰¾ä¸åˆ°ï¼Œç›´æŽ¥æŸ¥è¯¢ DOM
              scroller = document.querySelector('.vue-recycle-scroller');
            }
            
            if (scroller) {
              const scrollTop = scroller.scrollTop;
              const clientHeight = scroller.clientHeight;
              
              // ä¼°ç®—å¯è§èŒƒå›´
              const avgItemHeight = 80;
              const startIndex = Math.floor(scrollTop / avgItemHeight);
              const visibleCount = Math.ceil(clientHeight / avgItemHeight);
              const endIndex = Math.min(startIndex + visibleCount, filteredEvents.value.length);
              
              visibleRange.value = {
                start: Math.max(1, startIndex + 1),
                end: Math.max(1, endIndex)
              };
            }
          };
          
          // åˆå§‹æ›´æ–°å’Œæ·»åŠ æ»šåŠ¨ç›‘å¬
          setTimeout(() => {
            updateVisibleRange();
            
            const scroller = document.querySelector('.vue-recycle-scroller');
            if (scroller) {
              scroller.addEventListener('scroll', updateVisibleRange);
            }
          }, 500);
        });
        
        return {
          sessionId,
          metadata,
          sidebarCollapsed,
          expandedTools,
          expandedContent,
          currentFilter,
          searchText,
          activeTurnIndex,
          scrollerRef,
          visibleRange,
          loadedEvents,
          eventsLoading,
          eventsError,
          flatEvents,
          filteredEvents,
          eventCounts,
          filters,
          turns,
          toolCallMap,
          formatTime,
          formatDateTime,
          formatTimestamp,
          renderMarkdown,
          highlightSearchText,
          toggleTool,
          toggleContent,
          isContentTooLong,
          truncateContent,
          getBadgeInfo,
          getToolStatus,
          getToolErrorMessage,
          getToolDuration,
          getToolCommand,
          hasTools,
          getToolGroups,
          setFilter,
          scrollToTurn,
          getTurnNumber,
          exportSession,
          escapeHtml
        };
      },
      
      template: `
        <div class="container">
          <div class="header">
            <a href="/" class="home-btn">â† Back to Home</a>
            <h1>ðŸ“‹ Session: {{ sessionId }}</h1>
          </div>
          
          <div class="main-layout">
            <div :class="['sidebar', { collapsed: sidebarCollapsed }]">
              <div class="sidebar-section">
                <div class="sidebar-section-title">Session Info</div>
                <div class="session-info">
                  <div class="info-row">
                    <span class="info-label">Summary</span>
                    <span class="info-value">{{ metadata.summary || 'N/A' }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.model">
                    <span class="info-label">Model</span>
                    <span class="info-value">{{ metadata.model }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.repo">
                    <span class="info-label">Repo</span>
                    <span class="info-value">{{ metadata.repo }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.branch">
                    <span class="info-label">Branch</span>
                    <span class="info-value">{{ metadata.branch }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.cwd">
                    <span class="info-label">CWD</span>
                    <span class="info-value">{{ metadata.cwd }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.created">
                    <span class="info-label">Created</span>
                    <span class="info-value">{{ formatDateTime(metadata.created) }}</span>
                  </div>
                  <div class="info-row" v-if="metadata.updated">
                    <span class="info-label">Updated</span>
                    <span class="info-value">{{ formatDateTime(metadata.updated) }}</span>
                  </div>
                </div>
              </div>
              
              <div class="sidebar-section">
                <div class="sidebar-section-title">Turns</div>
                <div class="turn-buttons">
                  <button
                    v-for="turn in turns"
                    :key="turn.index"
                    :class="['turn-btn', { active: activeTurnIndex === turn.index }]"
                    @click="scrollToTurn(turn)"
                    :title="turn.message"
                  >
                    <div class="turn-btn-id">
                      <template v-if="turn.userReqNumber > 0">
                        UserReq {{ turn.userReqNumber }} - Turn {{ turn.id }} â€¢ {{ turn.duration }}
                      </template>
                      <template v-else>
                        Turn {{ turn.id }} â€¢ {{ turn.duration }}
                      </template>
                    </div>
                    <div class="turn-btn-message">{{ turn.message }}</div>
                  </button>
                </div>
              </div>
              
              <div class="sidebar-section">
                <div class="sidebar-section-title">Event Filters</div>
                <div class="event-filters">
                  <button
                    v-for="filter in filters"
                    :key="filter.type"
                    :class="['filter-btn', { active: currentFilter === filter.type }]"
                    :disabled="filter.disabled"
                    @click="setFilter(filter.type)"
                  >
                    {{ filter.label }}
                  </button>
                </div>
              </div>
            </div>
            
            <div class="content">
              <button 
                v-if="sidebarCollapsed"
                class="expand-btn"
                @click="sidebarCollapsed = false"
                title="Expand sidebar"
              >
                â˜° Show Sidebar
              </button>
              
              <div class="scroll-indicator">
                <div class="content-toolbar-left">
                  <button 
                    class="sidebar-toggle"
                    @click="sidebarCollapsed = !sidebarCollapsed"
                    :title="sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'"
                  >
                    â˜°
                  </button>
                  <button 
                    class="sidebar-toggle"
                    @click="exportSession"
                    title="Export session to HTML"
                    style="margin-left: 8px;"
                  >
                    ðŸ’¾ Export
                  </button>
                </div>
                <div class="content-toolbar-center">
                  <input 
                    v-model="searchText" 
                    type="text" 
                    placeholder="ðŸ” Search events..." 
                    class="search-input"
                  />
                </div>
                <div class="content-toolbar-right">
                  Showing {{ visibleRange.start || 1 }}-{{ visibleRange.end || Math.min(filteredEvents.length, 100) }} / {{ filteredEvents.length }}
                </div>
              </div>
              
              <!-- Loading state -->
              <div v-if="eventsLoading" class="loading-message">
                <div style="text-align: center; padding: 40px; color: #8b949e;">
                  â³ Loading events...
                </div>
              </div>
              
              <!-- Error state -->
              <div v-else-if="eventsError" class="error-message">
                <div style="text-align: center; padding: 40px; color: #f85149;">
                  âŒ Error loading events: {{ eventsError }}
                </div>
              </div>
              
              <!-- Events list -->
              <DynamicScroller
                v-else
                ref="scrollerRef"
                :items="filteredEvents"
                :min-item-size="20"
                key-field="virtualIndex"
                class="scroller"
              >
                <template #default="{ item, index, active }">
                  <DynamicScrollerItem
                    :item="item"
                    :active="active"
                    :size-dependencies="[expandedTools.size, expandedContent.size]"
                    :data-index="index"
                  >
                    <!-- Turn Start Divider -->
                    <div 
                      v-if="item.type === 'assistant.turn_start'"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                      class="turn-divider"
                    >
                      <div class="turn-divider-line-left"></div>
                      <span class="turn-divider-text">UserReq {{ getTurnNumber(item.virtualIndex) }} Start</span>
                      <div class="turn-divider-line-right"></div>
                    </div>
                    
                    <!-- Subagent Divider -->
                    <div 
                      v-else-if="item.type === 'subagent.started' || item.type === 'subagent.completed' || item.type === 'subagent.failed'"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                      :class="['subagent-divider', item.type.split('.')[1]]"
                    >
                      <div class="subagent-divider-line-left"></div>
                      <span class="subagent-divider-text">
                        ðŸ¤– {{ item.data?.agentDisplayName || item.data?.agentName || 'SubAgent' }}
                        {{ item.type === 'subagent.started' ? 'Start â–¶' : item.type === 'subagent.completed' ? 'Complete âœ“' : 'Failed âœ—' }}
                      </span>
                      <div class="subagent-divider-line-right"></div>
                    </div>
                    
                    <!-- Regular Event -->
                    <div 
                      v-else
                      :class="['event']"
                      :data-type="item.type"
                      :data-index="item.virtualIndex"
                      style="margin-bottom: 4px;"
                    >
                      <div class="event-header">
                        <span :class="['event-badge', getBadgeInfo(item.type).class]">
                          {{ getBadgeInfo(item.type).label }}
                        </span>
                        <span class="event-timestamp">{{ formatTime(item.timestamp) }}</span>
                      </div>
                      
                      <!-- Abort event: show reason -->
                      <div v-if="item.type === 'abort' && item.data?.reason" class="event-content">
                        <strong>Reason:</strong> {{ item.data.reason }}
                      </div>
                      
                      <!-- Session start: show type and selectedModel -->
                      <div v-else-if="item.type === 'session.start'" class="event-content">
                        <div v-if="item.data?.type"><strong>Type:</strong> {{ item.data.type }}</div>
                        <div v-if="item.data?.selectedModel"><strong>Model:</strong> {{ item.data.selectedModel }}</div>
                        <div v-if="item.data?.producer"><strong>Producer:</strong> {{ item.data.producer }}</div>
                      </div>
                      
                      <!-- Session resume: show resumeTime, eventCount, context -->
                      <div v-else-if="item.type === 'session.resume'" class="event-content">
                        <div v-if="item.data?.resumeTime"><strong>Resume Time:</strong> {{ formatDateTime(item.data.resumeTime) }}</div>
                        <div v-if="item.data?.eventCount"><strong>Event Count:</strong> {{ item.data.eventCount }}</div>
                        <div v-if="item.data?.context?.branch"><strong>Branch:</strong> {{ item.data.context.branch }}</div>
                        <div v-if="item.data?.context?.repository"><strong>Repository:</strong> {{ item.data.context.repository }}</div>
                        <div v-if="item.data?.context?.cwd"><strong>Working Directory:</strong> {{ item.data.context.cwd }}</div>
                      </div>
                      
                      <!-- Session error: show errorType + message -->
                      <div v-else-if="item.type === 'session.error' && (item.data?.errorType || item.data?.message)" class="event-content">
                        <div v-if="item.data?.errorType"><strong>Error Type:</strong> {{ item.data.errorType }}</div>
                        <div v-if="item.data?.message"><strong>Message:</strong> {{ item.data.message }}</div>
                      </div>
                      
                      <!-- Regular content -->
                      <div v-else-if="item.data?.message || item.data?.text || item.data?.content">
                        <div 
                          class="event-content"
                          v-html="highlightSearchText(
                            renderMarkdown(
                              expandedContent.has(item.virtualIndex) || !isContentTooLong(item.data?.message || item.data?.text || item.data?.content)
                                ? (item.data?.message || item.data?.text || item.data?.content)
                                : truncateContent(item.data?.message || item.data?.text || item.data?.content)
                            ),
                            searchText
                          )"
                        ></div>
                        <div 
                          v-if="isContentTooLong(item.data?.message || item.data?.text || item.data?.content)"
                          style="margin-top: 8px; text-align: right;"
                        >
                          <button 
                            @click="toggleContent(item.virtualIndex)"
                            style="background: none; border: 1px solid #30363d; color: #58a6ff; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;"
                          >
                            {{ expandedContent.has(item.virtualIndex) ? 'Show less â–²' : 'Show more â–¼' }}
                          </button>
                        </div>
                      </div>
                      
                      <div v-if="hasTools(item)" class="tool-list">
                        <div
                          v-for="(group, idx) in getToolGroups(item)"
                          :key="idx"
                          class="tool-item"
                        >
                          <div 
                            class="tool-header-line"
                            @click="toggleTool(\`\${item.virtualIndex}-\${idx}\`)"
                          >
                            <span class="tool-connector">{{ idx === getToolGroups(item).length - 1 ? 'â””â”€' : 'â”œâ”€' }}</span>
                            <span class="tool-expand-icon">{{ expandedTools.has(\`\${item.virtualIndex}-\${idx}\`) ? 'â–¼' : 'â–¶' }}</span>
                            <span class="tool-name">ðŸ”§&nbsp;{{ group.start?.data?.toolName || group.tool || 'Tool' }}</span>
                            <span :class="getToolStatus(group).color" style="margin-left: 4px;">({{ getToolStatus(group).icon }}{{ getToolDuration(group) ? ' ' + getToolDuration(group) : '' }})</span>
                            <span v-if="getToolCommand(group)" style="color: #7d8590; margin-left: 8px;">{{ getToolCommand(group) }}</span>
                            <span v-if="getToolErrorMessage(group)" style="color: #ff7b72; margin-left: 8px;">{{ getToolErrorMessage(group).length > 80 ? getToolErrorMessage(group).substring(0, 80) + '...' : getToolErrorMessage(group) }}</span>
                          </div>
                          
                          <div v-if="expandedTools.has(\`\${item.virtualIndex}-\${idx}\`)" class="tool-detail">
                            <div v-if="group.start?.data?.arguments" class="tool-detail-section">
                              <div class="tool-detail-title">Arguments:</div>
                              <div class="tool-detail-content">
                                <pre>{{ JSON.stringify(group.start.data.arguments, null, 2) }}</pre>
                              </div>
                            </div>
                            <div v-if="group.complete?.data?.result" class="tool-detail-section">
                              <div class="tool-detail-title">Result:</div>
                              <div class="tool-detail-content">
                                <pre>{{ JSON.stringify(group.complete.data.result, null, 2) }}</pre>
                              </div>
                            </div>
                            <div v-if="getToolErrorMessage(group)" class="tool-detail-section">
                              <div class="tool-detail-title">Error:</div>
                              <div class="tool-detail-content" style="color: #ff7b72;">
                                {{ getToolErrorMessage(group) }}
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </DynamicScrollerItem>
                </template>
              </DynamicScroller>
            </div>
          </div>
        </div>
      `
    });
    
    app.mount('#app');
  </script>
</body>
</html>
